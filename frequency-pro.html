<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>直观频谱合成器 Pro (CSV支持)</title>
<style>
  /* === 保持原有 CSS 样式 === */
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:#0f1724;color:#e6eef8;margin:0;padding:16px; min-height:100vh;}
  .wrap{max-width:900px;margin:0 auto; position: relative; z-index: 1;}
  h1{font-size:20px;margin:6px 0 12px; display:flex; justify-content:space-between; align-items:center;}
  .card{background:#0b1220;border:1px solid #1f2a44;border-radius:12px;padding:12px;margin-bottom:12px; position:relative;}
  label{font-size:13px;color:#9fb0d6;display:block;margin-top:8px}
  input,select,button{font-size:15px;padding:8px;border-radius:8px;border:1px solid #26364f;background:#081024;color:#e6eef8;width:100%;box-sizing:border-box}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .controls{display:flex;gap:8px;margin-top:12px;flex-wrap:wrap;align-items: flex-end;}
  button{cursor:pointer;transition:all 0.2s; font-weight:600;}
  button:hover{filter:brightness(1.1)}
  button:disabled{opacity:0.6;cursor:not-allowed;filter:grayscale(0.8);}
  button.primary{background:#3fa7ff;border:none;color:#032033}
  button.stop{background:#ff4757;border:none;color:#fff;}
  
  .plot-container { position: relative; width: 100%; height: 320px; overflow: hidden; background:#061225; border-radius:8px; border:1px solid #22314a;}
  canvas{display:block; width: 100%; height: 100%; cursor: crosshair;}
  
  .section-title { color:#3fa7ff; font-size:14px; font-weight:bold; margin-bottom:8px; display:block; border-bottom:1px solid #1f2a44; padding-bottom:4px; }
  .mode-desc { font-size:12px; color:#ffcf6b; margin-top:4px; font-style: italic;}
  .hint{font-size:12px;color:#95b7dc;margin-top:8px;line-height:1.4}

  /* 拖拽覆盖层 */
  #dropOverlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(63, 167, 255, 0.15);
    border: 4px dashed #3fa7ff;
    z-index: 999;
    display: none;
    pointer-events: none; /* 让事件穿透到底层处理 */
    justify-content: center; align-items: center;
    color: #3fa7ff; font-size: 24px; font-weight: bold;
    backdrop-filter: blur(2px);
  }
  #dropOverlay.active { display: flex; }
</style>
</head>
<body>

<div id="dropOverlay">松开鼠标导入 CSV 曲线</div>

<div class="wrap">
  <h1><span>直观频谱合成器 Pro</span> <span style="font-size:12px;color:#666">CSV Enabled</span></h1>

  <div class="card">
    <span class="section-title">频谱绘制 / CSV 导入</span>
    <div class="plot-container">
        <canvas id="canvas"></canvas>
    </div>
    <div class="hint">
      <b>操作指南：</b><br>
      • <b>绘图</b>：左键点击/拖拽加点，双击删点。<br>
      • <b>导入</b>：<span style="color:#3fa7ff;font-weight:bold;">将扫频 CSV 文件直接拖入此页面</span>，自动复刻频响曲线。<br>
      • <b>缩放</b>：滚轮缩放频率轴 (0-40kHz)，右键拖拽平移。
    </div>
  </div>

  <div class="card">
    <span class="section-title">合成引擎控制</span>
    <div class="row">
      <div>
        <label>合成模式 (Synthesis Mode)</label>
        <select id="synthMode">
          <option value="noise" selected>1. 频谱噪音 (Spectral Noise)</option>
          <option value="harmonic">2. 丰富谐波 (Rich Harmonics)</option>
        </select>
        <div id="modeDesc" class="mode-desc">
            根据曲线生成“有色噪音”。画哪里，哪里就有声音。
        </div>
      </div>
      <div>
        <label>总音量 (Volume)</label>
        <input id="masterGain" type="range" min="0" max="1" step="0.01" value="0.5" />
      </div>
    </div>
    
    <div id="harmonicControls" style="display:none; margin-top:8px;">
        <label>基频音高 (Hz)</label>
        <input id="fundFreq" type="range" min="50" max="800" step="1" value="110" />
        <span id="freqVal" style="font-size:12px; float:right; color:#3fa7ff">110 Hz</span>
    </div>

    <div class="controls">
      <button id="btnStart" class="primary" style="flex:2">开始生成并播放</button>
      <button id="btnStop" class="stop" style="flex:1" disabled>停止</button>
    </div>
    
    <div class="hint" style="margin-top:12px; border-top:1px solid #1f2a44; padding-top:8px;">
        状态: <span id="statusText" style="color:#3fa7ff">就绪</span>
    </div>
  </div>
</div>

<script>
// ==================== 1. MiniFFT (修复版) ====================
class MiniFFT {
    constructor(size) {
        this.size = size;
        this.levels = Math.log2(size);
        if (Math.pow(2, this.levels) !== size) throw "FFT size must be power of 2";
        this.cosTable = new Float32Array(size / 2);
        this.sinTable = new Float32Array(size / 2);
        for (let i = 0; i < size / 2; i++) {
            this.cosTable[i] = Math.cos(2 * Math.PI * i / size);
            this.sinTable[i] = Math.sin(2 * Math.PI * i / size);
        }
        this.reverseTable = new Uint32Array(size);
        for (let i = 0; i < size; i++) {
            let rev = 0;
            for (let j = 0; j < this.levels; j++) {
                if ((i >> j) & 1) rev |= (1 << (this.levels - 1 - j));
            }
            this.reverseTable[i] = rev;
        }
    }
    
    // === 修复：补回了缺失的方法 ===
    createComplexArray() { 
        return new Float32Array(this.size * 2); 
    }

    inverseTransform(outReal, inputComplex) {
        this.transform(inputComplex, true);
        for (let i = 0; i < this.size; i++) outReal[i] = inputComplex[2 * i];
    }

    transform(data, inverse) {
        const n = this.size;
        for (let i = 0; i < n; i++) {
            const rev = this.reverseTable[i];
            if (i < rev) {
                let tr = data[2 * i], ti = data[2 * i + 1];
                data[2 * i] = data[2 * rev]; data[2 * i + 1] = data[2 * rev + 1];
                data[2 * rev] = tr; data[2 * rev + 1] = ti;
            }
        }
        for (let size = 2; size <= n; size *= 2) {
            const halfsize = size / 2;
            const tablestep = n / size;
            for (let i = 0; i < n; i += size) {
                for (let j = 0, k = 0; j < halfsize; j++, k += tablestep) {
                    const idx1 = 2 * (i + j);
                    const idx2 = 2 * (i + j + halfsize);
                    const tpre = data[idx2];
                    const tpim = data[idx2 + 1];
                    let cost = this.cosTable[k], sint = this.sinTable[k];
                    if (inverse) sint = -sint;
                    const re = tpre * cost - tpim * sint;
                    const im = tpre * sint + tpim * cost;
                    data[idx2] = data[idx1] - re;
                    data[idx2 + 1] = data[idx1 + 1] - im;
                    data[idx1] += re;
                    data[idx1 + 1] += im;
                }
            }
        }
        if (inverse) {
            const f = 1.0 / n;
            for (let i = 0; i < 2 * n; i++) data[i] *= f;
        }
    }
}

// ==================== 2. 全局变量 ====================
const $ = id => document.getElementById(id);
let audioCtx = null;
let bufferSource = null;
let gainNode = null;
let isPlaying = false;
let updateTimeout = null;

const view = { minFreq: 0, maxFreq: 22000, freqLimit: 40000 };
// 数据点：{f:频率Hz, a:线性幅度0-1}
let points = [
    { f: 0, a: 0.8 },
    { f: 400, a: 0.6 },
    { f: 2000, a: 0.3 },
    { f: 10000, a: 0.1 },
    { f: 40000, a: 0.0 }
];

let activePoint = null;
let isDragging = false;
let isPanning = false;
let lastMouseX = 0;

// ==================== 3. Canvas 绘图 ====================
const canvas = $('canvas');
const g = canvas.getContext('2d');

function resize() {
    const p = canvas.parentNode.getBoundingClientRect();
    canvas.width = p.width; canvas.height = p.height;
    draw();
}
window.addEventListener('resize', resize);

const xToFreq = x => view.minFreq + (x/canvas.width)*(view.maxFreq - view.minFreq);
const freqToX = f => ((f - view.minFreq)/(view.maxFreq - view.minFreq))*canvas.width;
const yToAmp = y => 1 - (y/canvas.height);
const ampToY = a => (1 - a)*canvas.height;

function sortPoints() { points.sort((a,b) => a.f - b.f); }

function getCurveAmplitude(freq) {
    if(points.length === 0) return 0;
    if(freq <= points[0].f) return points[0].a;
    if(freq >= points[points.length-1].f) return points[points.length-1].a;
    
    // 简单的线性插值
    // 如果点非常多(CSV导入)，这里可以用二分查找优化，但现代JS引擎对几百个点也没问题
    for(let i=0; i<points.length-1; i++) {
        if(freq >= points[i].f && freq <= points[i+1].f) {
            const t = (freq - points[i].f) / (points[i+1].f - points[i].f);
            return points[i].a + t * (points[i+1].a - points[i].a);
        }
    }
    return 0;
}

function draw() {
    const w = canvas.width, h = canvas.height;
    g.fillStyle = "#061225"; g.fillRect(0,0,w,h);
    
    // 网格
    g.lineWidth = 1; g.strokeStyle = "#1f2a44"; g.fillStyle = "#5c6b8f"; g.font = "10px sans-serif";
    for(let i=0; i<=5; i++) {
        const y = ampToY(i/5);
        g.beginPath(); g.moveTo(0,y); g.lineTo(w,y); g.stroke();
        g.textAlign = "left"; g.fillText((i/5).toFixed(1), 5, y-2);
    }
    const range = view.maxFreq - view.minFreq;
    let step = 2000;
    if(range < 5000) step = 500;
    if(range > 20000) step = 5000;
    const start = Math.ceil(view.minFreq/step)*step;
    for(let f=start; f<view.maxFreq; f+=step) {
        const x = freqToX(f);
        g.beginPath(); g.moveTo(x,0); g.lineTo(x,h); g.stroke();
        g.textAlign = "center"; g.fillText(f, x, h-5);
    }

    // 曲线
    sortPoints();
    if(points.length > 0) {
        g.beginPath();
        g.moveTo(freqToX(0), ampToY(points[0].a));
        for(let p of points) g.lineTo(freqToX(p.f), ampToY(p.a));
        g.lineTo(freqToX(40000), ampToY(points[points.length-1].a));
        g.lineTo(freqToX(40000), h);
        g.lineTo(freqToX(0), h);
        g.fillStyle = "rgba(63, 167, 255, 0.2)";
        g.fill();
        
        g.beginPath();
        g.strokeStyle = "#3fa7ff"; g.lineWidth = 3;
        g.moveTo(freqToX(0), ampToY(points[0].a));
        for(let p of points) g.lineTo(freqToX(p.f), ampToY(p.a));
        g.lineTo(freqToX(40000), ampToY(points[points.length-1].a));
        g.stroke();
    }

    // 控制点 (如果是CSV导入的大量点，就不绘制圆点，只显示线)
    if(points.length < 100) {
        for(let p of points) {
            const x = freqToX(p.f);
            if(x > -10 && x < w+10) {
                g.beginPath();
                g.arc(x, ampToY(p.a), p===activePoint?8:5, 0, Math.PI*2);
                g.fillStyle = p===activePoint?"#fff":"#3fa7ff"; g.fill();
                g.strokeStyle="#fff"; g.lineWidth=2; g.stroke();
            }
        }
    }
}

// ==================== 4. 交互 (含 CSV 拖拽) ====================

// --- CSV 拖拽逻辑 ---
const dropOverlay = $('dropOverlay');

window.addEventListener('dragover', e => { e.preventDefault(); dropOverlay.classList.add('active'); });
window.addEventListener('dragleave', e => { 
    if (e.relatedTarget === null) dropOverlay.classList.remove('active'); 
});
window.addEventListener('drop', e => {
    e.preventDefault();
    dropOverlay.classList.remove('active');
    
    if(e.dataTransfer.files && e.dataTransfer.files.length > 0) {
        parseCSV(e.dataTransfer.files[0]);
    }
});

function parseCSV(file) {
    const reader = new FileReader();
    reader.onload = (e) => {
        const text = e.target.result;
        const lines = text.split(/\r?\n/);
        
        let newPoints = [];
        let freqIdx = -1, ampIdx = -1;
        
        // 1. 寻找表头
        if(lines.length > 0) {
            const header = lines[0].toLowerCase().split(',');
            header.forEach((col, idx) => {
                if(col.includes('freq') || col.includes('hz')) freqIdx = idx;
                if(col.includes('amp') || col.includes('db') || col.includes('h1')) ampIdx = idx;
            });
        }
        
        if(freqIdx === -1 || ampIdx === -1) {
            // 如果没有表头，尝试默认 0和1列
            freqIdx = 0; ampIdx = 1;
        }

        // 2. 解析数据
        for(let i=1; i<lines.length; i++) {
            const cols = lines[i].split(',');
            if(cols.length < 2) continue;
            
            let f = parseFloat(cols[freqIdx]);
            let val = parseFloat(cols[ampIdx]);
            
            if(isNaN(f) || isNaN(val)) continue;
            if(f < 0 || f > 40000) continue;

            // 3. 处理幅度单位
            // 假设 CSV 里的通常是 dB (如 -100 到 0) 或者是 线性 (0-1)
            // 简单的启发式判断：如果大部分值 < 0，认为是 dB
            // 但为了保险，我们把 dB 转线性
            // 通常 dB = 20 * log10(Linear)  => Linear = 10 ^ (dB / 20)
            let lin = val;
            
            // 如果值明显是 dB (例如 -20, -60)，转换它
            // 如果是 0.5, 0.8，则保持
            // 简单逻辑：如果值小于 -1 或者 大于 1 (不太可能)，当做dB处理
            // 或者如果用户是用上一个工具导出的，它是 dB。
            if(val < 0) {
                lin = Math.pow(10, val / 20);
            }
            // 钳位
            lin = Math.max(0, Math.min(1, lin));

            newPoints.push({f: f, a: lin});
        }

        if(newPoints.length > 0) {
            // 4. 优化：如果点太多 (>200)，为了性能进行降采样
            // 保留极值特征会比较复杂，这里采用简单的步进采样
            if(newPoints.length > 200) {
                const optimized = [];
                const step = Math.ceil(newPoints.length / 200);
                for(let i=0; i<newPoints.length; i+=step) {
                    optimized.push(newPoints[i]);
                }
                // 确保收尾都在
                if(optimized[optimized.length-1] !== newPoints[newPoints.length-1]) {
                    optimized.push(newPoints[newPoints.length-1]);
                }
                newPoints = optimized;
            }

            points = newPoints;
            sortPoints();
            $('statusText').textContent = `已导入 CSV (${points.length} 点)`;
            draw();
            updateSoundBuffer();
        } else {
            alert("无法解析 CSV 数据，请检查格式。");
        }
    };
    reader.readAsText(file);
}

// --- 常规交互 ---
canvas.addEventListener('mousedown', e => {
    const r = canvas.getBoundingClientRect();
    const x = e.clientX - r.left, y = e.clientY - r.top;
    
    if(e.button === 2) { isPanning = true; lastMouseX = e.clientX; return; }

    let hit = null, minD = 20;
    // 如果点太多，增加点击难度或只允许新增，这里仅在前100个点时允许拖拽
    if(points.length < 100) {
        points.forEach(p => {
            const px = freqToX(p.f), py = ampToY(p.a);
            const d = Math.sqrt((x-px)**2 + (y-py)**2);
            if(d < minD) { minD = d; hit = p; }
        });
    }

    if(hit) {
        activePoint = hit; isDragging = true;
    } else {
        const newP = { f: Math.max(0, xToFreq(x)), a: Math.max(0, Math.min(1, yToAmp(y))) };
        points.push(newP); activePoint = newP; isDragging = true;
        sortPoints();
        updateSoundBuffer();
    }
    draw();
});

window.addEventListener('mousemove', e => {
    if(isPanning) {
        const dx = e.clientX - lastMouseX; lastMouseX = e.clientX;
        const shift = -(dx/canvas.width)*(view.maxFreq - view.minFreq);
        view.minFreq = Math.max(0, view.minFreq+shift);
        view.maxFreq = Math.min(view.freqLimit, view.maxFreq+shift);
        draw(); return;
    }
    if(!isDragging || !activePoint) return;
    
    const r = canvas.getBoundingClientRect();
    const f = Math.max(0, Math.min(view.freqLimit, xToFreq(e.clientX - r.left)));
    const a = Math.max(0, Math.min(1, yToAmp(e.clientY - r.top)));
    
    activePoint.f = parseFloat(f.toFixed(1)); activePoint.a = a;
    draw();
    
    if(isPlaying && !updateTimeout) {
        updateTimeout = setTimeout(() => { updateSoundBuffer(); updateTimeout = null; }, 50);
    }
});

window.addEventListener('mouseup', () => {
    isDragging = false; isPanning = false; activePoint = null;
    if(isPlaying) updateSoundBuffer();
});

canvas.addEventListener('dblclick', e => {
    const r = canvas.getBoundingClientRect();
    const x = e.clientX - r.left, y = e.clientY - r.top;
    let hitIdx = -1, minD = 20;
    points.forEach((p,i) => {
        const d = Math.sqrt((x-freqToX(p.f))**2 + (y-ampToY(p.a))**2);
        if(d < minD) { minD = d; hitIdx = i; }
    });
    if(hitIdx >= 0 && points.length > 2) {
        points.splice(hitIdx, 1);
        draw(); updateSoundBuffer();
    }
});

canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const r = canvas.getBoundingClientRect();
    const mF = xToFreq(e.clientX - r.left);
    const zoom = e.deltaY > 0 ? 1.1 : 0.9;
    const range = (view.maxFreq - view.minFreq) * zoom;
    const ratio = (mF - view.minFreq)/(view.maxFreq - view.minFreq);
    view.minFreq = Math.max(0, mF - range*ratio);
    view.maxFreq = Math.min(view.freqLimit, mF + range*(1-ratio));
    draw();
}, {passive:false});
canvas.addEventListener('contextmenu', e => e.preventDefault());


// ==================== 5. 音频合成引擎 ====================
function initAudio() {
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if(!gainNode) {
        gainNode = audioCtx.createGain();
        gainNode.gain.value = 0.5;
        gainNode.connect(audioCtx.destination);
    }
}

function generateBuffer() {
    if(!audioCtx) return null;
    const size = 16384; 
    const fft = new MiniFFT(size);
    const complex = fft.createComplexArray();
    const mode = $('synthMode').value;
    const sr = audioCtx.sampleRate;
    const binSize = sr / size;
    const nyquistBin = size / 2;
    const fundFreq = parseFloat($('fundFreq').value);
    
    if (mode === 'noise') {
        for(let i = 1; i < nyquistBin; i++) {
            const freq = i * binSize;
            const amp = getCurveAmplitude(freq);
            const phase = Math.random() * 2 * Math.PI;
            const scale = amp * 0.5; 
            complex[2*i] = scale * Math.cos(phase);
            complex[2*i+1] = scale * Math.sin(phase);
        }
    } else {
        for(let n = 1; ; n++) {
            const freq = n * fundFreq;
            if(freq >= sr/2) break;
            const bin = Math.round(freq / binSize);
            if(bin >= nyquistBin) break;
            const amp = getCurveAmplitude(freq);
            const phase = Math.random() * 2 * Math.PI;
            const scale = amp * 100; 
            complex[2*bin] = scale * Math.cos(phase);
            complex[2*bin+1] = scale * Math.sin(phase);
        }
    }
    
    const timeDomain = new Float32Array(size);
    fft.inverseTransform(timeDomain, complex);
    
    const buffer = audioCtx.createBuffer(1, size, sr);
    const data = buffer.getChannelData(0);
    for(let i=0; i<size; i++) data[i] = timeDomain[i];
    return buffer;
}

function updateSoundBuffer() {
    if(!isPlaying || !audioCtx) return;
    const newBuf = generateBuffer();
    
    const newSource = audioCtx.createBufferSource();
    newSource.buffer = newBuf;
    newSource.loop = true;
    newSource.connect(gainNode);
    newSource.start();
    
    const oldSource = bufferSource;
    bufferSource = newSource;
    
    if(oldSource) oldSource.stop(audioCtx.currentTime + 0.05);
}

$('btnStart').onclick = async () => {
    initAudio();
    await audioCtx.resume();
    bufferSource = audioCtx.createBufferSource();
    bufferSource.buffer = generateBuffer();
    bufferSource.loop = true;
    bufferSource.connect(gainNode);
    bufferSource.start();
    isPlaying = true;
    $('btnStart').disabled = true; $('btnStop').disabled = false;
    $('statusText').textContent = "正在合成并播放...";
};

$('btnStop').onclick = () => {
    if(bufferSource) { try{ bufferSource.stop(); }catch(e){} bufferSource.disconnect(); }
    isPlaying = false;
    $('btnStart').disabled = false; $('btnStop').disabled = true;
    $('statusText').textContent = "已停止";
};

$('masterGain').oninput = function() { if(gainNode) gainNode.gain.value = this.value; };
$('synthMode').onchange = function() {
    $('harmonicControls').style.display = this.value === 'harmonic' ? 'block' : 'none';
    $('modeDesc').textContent = this.value === 'noise' 
        ? "基于曲线生成有色噪音 (高频=嘶嘶, 低频=轰隆)。" 
        : "基于基频产生谐波，曲线决定谐波音量。";
    updateSoundBuffer();
};
$('fundFreq').oninput = function() {
    $('freqVal').textContent = this.value + " Hz";
    if($('synthMode').value === 'harmonic') updateSoundBuffer();
};

resize();
</script>
</body>
</html>
