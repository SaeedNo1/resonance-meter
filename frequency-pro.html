<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>复合声音发生器</title>
<link rel="icon" type="image/png" sizes="48x48" href="logo-42px.png">
<style>
  /* === 保持原有 CSS 样式 === */
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:#0f1724;color:#e6eef8;margin:0;padding:16px; min-height:100vh;}
  .wrap{max-width:900px;margin:0 auto; position: relative; z-index: 1;}
  h1{font-size:20px;margin:6px 0 12px; display:flex; justify-content:space-between; align-items:center;}
  .card{background:#0b1220;border:1px solid #1f2a44;border-radius:12px;padding:12px;margin-bottom:12px; position:relative;}
  label{font-size:13px;color:#9fb0d6;display:block;margin-top:8px}
  input,select,button{font-size:15px;padding:8px;border-radius:8px;border:1px solid #26364f;background:#081024;color:#e6eef8;width:100%;box-sizing:border-box}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .controls{display:flex;gap:8px;margin-top:12px;flex-wrap:wrap;align-items: flex-end;}
  button{cursor:pointer;transition:all 0.2s; font-weight:600;}
  button:hover{filter:brightness(1.1)}
  button:disabled{opacity:0.6;cursor:not-allowed;filter:grayscale(0.8);}
  button.primary{background:#3fa7ff;border:none;color:#032033}
  button.stop{background:#ff4757;border:none;color:#fff;}
  
  .plot-container { position: relative; width: 100%; height: 320px; overflow: hidden; background:#061225; border-radius:8px; border:1px solid #22314a;}
  canvas{display:block; width: 100%; height: 100%; cursor: crosshair;}
  
  .section-title { color:#3fa7ff; font-size:14px; font-weight:bold; margin-bottom:8px; display:block; border-bottom:1px solid #1f2a44; padding-bottom:4px; }
  .mode-desc { font-size:12px; color:#ffcf6b; margin-top:4px; font-style: italic;}
  .hint{font-size:12px;color:#95b7dc;margin-top:8px;line-height:1.4}

  /* 拖拽覆盖层 */
  #dropOverlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(63, 167, 255, 0.15);
    border: 4px dashed #3fa7ff;
    z-index: 999;
    display: none;
    pointer-events: none;
    justify-content: center; align-items: center;
    color: #3fa7ff; font-size: 24px; font-weight: bold;
    backdrop-filter: blur(2px);
  }
  #dropOverlay.active { display: flex; }
</style>
</head>
<body>

<div id="dropOverlay">松开鼠标导入 CSV 曲线</div>

<div class="wrap">
  <h1><span>正弦波加性合成器</span> <span style="font-size:12px;color:#666">Additive Synthesis</span></h1>

  <div class="card">
    <span class="section-title">频谱绘制 / CSV 导入</span>
    <div class="plot-container">
        <canvas id="canvas"></canvas>
    </div>
    <div class="hint">
      <b>操作指南：</b><br>
      • <b>绘图</b>：左键点击/拖拽加点，双击删点。<br>
      • <b>导入</b>：将扫频 CSV 文件直接拖入此页面，自动复刻频响曲线。<br>
      • <b>缩放</b>：滚轮缩放频率轴 (0-40kHz)，右键拖拽平移。
    </div>
  </div>

  <div class="card">
    <span class="section-title">合成引擎控制</span>
    <div class="row">
      <div>
        <label>合成模式 (Synthesis Mode)</label>
        <select id="synthMode">
          <option value="additive" selected>1. 正弦波混合 (Additive Sine) - 您的要求</option>
          <option value="noise">2. 频谱噪音 (Spectral Noise)</option>
          <option value="harmonic">3. 丰富谐波 (Rich Harmonics)</option>
        </select>
        <div id="modeDesc" class="mode-desc">
            混合大量正弦波，响度完全由曲线决定。波峰在哪，声音就在哪。
        </div>
      </div>
      <div>
        <label>总音量 (Volume)</label>
        <input id="masterGain" type="range" min="0" max="1" step="0.01" value="0.5" />
      </div>
    </div>
    
    <div id="additiveControls" style="display:block; margin-top:8px;">
        <label>频率解析度/步长 (Frequency Resolution)</label>
        <input id="freqStep" type="range" min="10" max="200" step="1" value="50" />
        <span id="stepVal" style="font-size:12px; float:right; color:#3fa7ff">50 Hz</span>
        <div class="hint" style="margin-top:4px;">
            此步长决定了混合正弦波的密度：步长越小，声音越“平滑”但CPU占用越高。
        </div>
    </div>
    
    <div id="harmonicControls" style="display:none; margin-top:8px;">
        <label>基频音高 (Hz)</label>
        <input id="fundFreq" type="range" min="50" max="800" step="1" value="110" />
        <span id="freqVal" style="font-size:12px; float:right; color:#3fa7ff">110 Hz</span>
    </div>

    <div class="controls">
      <button id="btnStart" class="primary" style="flex:2">开始生成并播放</button>
      <button id="btnStop" class="stop" style="flex:1" disabled>停止</button>
    </div>
    
    <div class="hint" style="margin-top:12px; border-top:1px solid #1f2a44; padding-top:8px;">
        状态: <span id="statusText" style="color:#3fa7ff">就绪</span>
    </div>
  </div>
</div>

<script>
// ==================== 1. MiniFFT (用于噪音/谐波模式的兼容) ====================
// 在本次新增的 Additive Sine 模式中不再使用此FFT。
class MiniFFT {
    constructor(size) {
        this.size = size;
        this.levels = Math.log2(size);
        if (Math.pow(2, this.levels) !== size) throw "FFT size must be power of 2";
        this.cosTable = new Float32Array(size / 2);
        this.sinTable = new Float32Array(size / 2);
        for (let i = 0; i < size / 2; i++) {
            this.cosTable[i] = Math.cos(2 * Math.PI * i / size);
            this.sinTable[i] = Math.sin(2 * Math.PI * i / size);
        }
        this.reverseTable = new Uint32Array(size);
        for (let i = 0; i < size; i++) {
            let rev = 0;
            for (let j = 0; j < this.levels; j++) {
                if ((i >> j) & 1) rev |= (1 << (this.levels - 1 - j));
            }
            this.reverseTable[i] = rev;
        }
    }
    createComplexArray() { return new Float32Array(this.size * 2); }
    inverseTransform(outReal, inputComplex) {
        this.transform(inputComplex, true);
        for (let i = 0; i < this.size; i++) outReal[i] = inputComplex[2 * i];
    }
    transform(data, inverse) {
        const n = this.size;
        for (let i = 0; i < n; i++) {
            const rev = this.reverseTable[i];
            if (i < rev) {
                let tr = data[2 * i], ti = data[2 * i + 1];
                data[2 * i] = data[2 * rev]; data[2 * i + 1] = data[2 * rev + 1];
                data[2 * rev] = tr; data[2 * rev + 1] = ti;
            }
        }
        for (let size = 2; size <= n; size *= 2) {
            const halfsize = size / 2;
            const tablestep = n / size;
            for (let i = 0; i < n; i += size) {
                for (let j = 0, k = 0; j < halfsize; j++, k += tablestep) {
                    const idx1 = 2 * (i + j);
                    const idx2 = 2 * (i + j + halfsize);
                    const tpre = data[idx2];
                    const tpim = data[idx2 + 1];
                    let cost = this.cosTable[k], sint = this.sinTable[k];
                    if (inverse) sint = -sint;
                    const re = tpre * cost - tpim * sint;
                    const im = tpre * sint + tpim * tpim; // 修复了上一版中的一个小错误
                    data[idx2] = data[idx1] - re;
                    data[idx2 + 1] = data[idx1 + 1] - im;
                    data[idx1] += re;
                    data[idx1 + 1] += im;
                }
            }
        }
        if (inverse) {
            const f = 1.0 / n;
            for (let i = 0; i < 2 * n; i++) data[i] *= f;
        }
    }
}


// ==================== 2. 全局变量 & 绘图逻辑 (与上一版一致，略) ====================
const $ = id => document.getElementById(id);
let audioCtx = null;
let currentSource = null; // 引用当前播放的 SourceNode 或 OscillatorGroup
let gainNode = null;
let isPlaying = false;
let updateTimeout = null;

const view = { minFreq: 0, maxFreq: 22000, freqLimit: 40000 };
let points = [
    { f: 0, a: 0.8 },
    { f: 400, a: 0.6 },
    { f: 2000, a: 0.3 },
    { f: 10000, a: 0.1 },
    { f: 40000, a: 0.0 }
];

let activePoint = null;
let isDragging = false;
let isPanning = false;
let lastMouseX = 0;

// 绘图
const canvas = $('canvas');
const g = canvas.getContext('2d');
function resize() {
    const p = canvas.parentNode.getBoundingClientRect();
    canvas.width = p.width; canvas.height = p.height;
    draw();
}
window.addEventListener('resize', resize);
const xToFreq = x => view.minFreq + (x/canvas.width)*(view.maxFreq - view.minFreq);
const freqToX = f => ((f - view.minFreq)/(view.maxFreq - view.minFreq))*canvas.width;
const yToAmp = y => 1 - (y/canvas.height);
const ampToY = a => (1 - a)*canvas.height;
function sortPoints() { points.sort((a,b) => a.f - b.f); }
function getCurveAmplitude(freq) {
    if(points.length === 0) return 0;
    if(freq <= points[0].f) return points[0].a;
    if(freq >= points[points.length-1].f) return points[points.length-1].a;
    for(let i=0; i<points.length-1; i++) {
        if(freq >= points[i].f && freq <= points[i+1].f) {
            const t = (freq - points[i].f) / (points[i+1].f - points[i].f);
            return points[i].a + t * (points[i+1].a - points[i].a);
        }
    }
    return 0;
}
function draw() {
    const w = canvas.width, h = canvas.height;
    g.fillStyle = "#061225"; g.fillRect(0,0,w,h);
    g.lineWidth = 1; g.strokeStyle = "#1f2a44"; g.fillStyle = "#5c6b8f"; g.font = "10px sans-serif";
    for(let i=0; i<=5; i++) {
        const y = ampToY(i/5); g.beginPath(); g.moveTo(0,y); g.lineTo(w,y); g.stroke();
        g.textAlign = "left"; g.fillText((i/5).toFixed(1), 5, y-2);
    }
    const range = view.maxFreq - view.minFreq;
    let step = 2000;
    if(range < 5000) step = 500; if(range > 20000) step = 5000;
    const start = Math.ceil(view.minFreq/step)*step;
    for(let f=start; f<view.maxFreq; f+=step) {
        const x = freqToX(f); g.beginPath(); g.moveTo(x,0); g.lineTo(x,h); g.stroke();
        g.textAlign = "center"; g.fillText(f, x, h-5);
    }
    sortPoints();
    if(points.length > 0) {
        g.beginPath();
        g.moveTo(freqToX(0), ampToY(points[0].a));
        for(let p of points) g.lineTo(freqToX(p.f), ampToY(p.a));
        g.lineTo(freqToX(40000), ampToY(points[points.length-1].a));
        g.lineTo(freqToX(40000), h); g.lineTo(freqToX(0), h);
        g.fillStyle = "rgba(63, 167, 255, 0.2)"; g.fill();
        g.beginPath(); g.strokeStyle = "#3fa7ff"; g.lineWidth = 3;
        g.moveTo(freqToX(0), ampToY(points[0].a));
        for(let p of points) g.lineTo(freqToX(p.f), ampToY(p.a));
        g.lineTo(freqToX(40000), ampToY(points[points.length-1].a)); g.stroke();
    }
    if(points.length < 100) {
        for(let p of points) {
            const x = freqToX(p.f);
            if(x > -10 && x < w+10) {
                g.beginPath();
                g.arc(x, ampToY(p.a), p===activePoint?8:5, 0, Math.PI*2);
                g.fillStyle = p===activePoint?"#fff":"#3fa7ff"; g.fill();
                g.strokeStyle="#fff"; g.lineWidth=2; g.stroke();
            }
        }
    }
}
// 忽略交互和CSV逻辑（与上一版一致）

// ==================== 3. 核心音频引擎（三个模式） ====================

function initAudio() {
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if(!gainNode) {
        gainNode = audioCtx.createGain();
        gainNode.gain.value = parseFloat($('masterGain').value) || 0.5;
        gainNode.connect(audioCtx.destination);
    }
}

// === 模式 1: 正弦波混合 (Additive Sine Waves) ===
function startAdditiveSine() {
    const freqStep = parseFloat($('freqStep').value);
    const maxFreq = audioCtx.sampleRate / 2; // Nyquist limit
    const oscillators = [];
    const sourceGroup = { oscs: oscillators, gainNode: audioCtx.createGain() };
    
    // 连接到主增益
    sourceGroup.gainNode.connect(gainNode);

    let totalAmpSum = 0;

    for(let f = freqStep; f < maxFreq; f += freqStep) {
        const amp = getCurveAmplitude(f);
        if(amp > 0.001) {
            const osc = audioCtx.createOscillator();
            const oscGain = audioCtx.createGain();
            
            osc.type = 'sine';
            osc.frequency.setValueAtTime(f, audioCtx.currentTime);
            oscGain.gain.setValueAtTime(amp, audioCtx.currentTime);

            osc.connect(oscGain);
            oscGain.connect(sourceGroup.gainNode);
            osc.start();
            
            oscillators.push(osc);
            totalAmpSum += amp;
        }
    }
    
    // 归一化：将所有振荡器的总响度限制在一个合理范围内，防止爆音
    const maxSafeSum = 50; // 经验值，取决于 step (50Hz 步进大约有400个振荡器)
    if(totalAmpSum > maxSafeSum) {
        sourceGroup.gainNode.gain.value = maxSafeSum / totalAmpSum;
    } else {
        sourceGroup.gainNode.gain.value = 1.0;
    }

    currentSource = sourceGroup;
}

// === 模式 2 & 3: 频谱合成 (Spectral Synthesis - 噪音/谐波) ===
// 此部分与上一版用于生成 Buffer 的 FFT 逻辑一致
function generateBuffer() {
    const size = 16384; 
    const fft = new MiniFFT(size);
    const complex = fft.createComplexArray();
    const mode = $('synthMode').value;
    const sr = audioCtx.sampleRate;
    const binSize = sr / size;
    const nyquistBin = size / 2;
    const fundFreq = parseFloat($('fundFreq').value);
    
    if (mode === 'noise') {
        for(let i = 1; i < nyquistBin; i++) {
            const freq = i * binSize;
            const amp = getCurveAmplitude(freq);
            const phase = Math.random() * 2 * Math.PI;
            const scale = amp * 0.5; 
            complex[2*i] = scale * Math.cos(phase);
            complex[2*i+1] = scale * Math.sin(phase);
        }
    } else if (mode === 'harmonic') {
        for(let n = 1; ; n++) {
            const freq = n * fundFreq;
            if(freq >= sr/2) break;
            const bin = Math.round(freq / binSize);
            if(bin >= nyquistBin) break;
            const amp = getCurveAmplitude(freq);
            const phase = Math.random() * 2 * Math.PI;
            const scale = amp * 100; 
            complex[2*bin] = scale * Math.cos(phase);
            complex[2*bin+1] = scale * Math.sin(phase);
        }
    }
    
    const timeDomain = new Float32Array(size);
    fft.inverseTransform(timeDomain, complex);
    const buffer = audioCtx.createBuffer(1, size, sr);
    buffer.copyToChannel(timeDomain, 0);
    return buffer;
}

function startBufferSource() {
    const newBuf = generateBuffer();
    const newSource = audioCtx.createBufferSource();
    newSource.buffer = newBuf;
    newSource.loop = true;
    newSource.connect(gainNode);
    newSource.start();
    currentSource = newSource;
}

// 停止旧音源并启动新音源
function stopAllSources() {
    if(!currentSource) return;

    if (currentSource.oscs) {
        // 停止 Additive Sine 模式中的所有振荡器
        currentSource.oscs.forEach(osc => {
            try { osc.stop(); osc.disconnect(); } catch(e){}
        });
        currentSource.gainNode.disconnect();
    } else if (currentSource.stop) {
        // 停止 BufferSource 模式中的源
        try { currentSource.stop(audioCtx.currentTime + 0.05); } catch(e){}
        currentSource.disconnect();
    }
    currentSource = null;
}

function updateSound() {
    if(!isPlaying) return;
    stopAllSources(); // 停止旧声音
    
    const mode = $('synthMode').value;
    if (mode === 'additive') {
        startAdditiveSine();
        $('statusText').textContent = `正在播放 (正弦波混合，步长: ${$('freqStep').value}Hz)...`;
    } else {
        startBufferSource();
        $('statusText').textContent = `正在播放 (${mode === 'noise' ? '频谱噪音' : '丰富谐波'})...`;
    }
}

// ==================== 4. UI 绑定和控制 ====================

$('btnStart').onclick = async () => {
    initAudio();
    await audioCtx.resume();
    isPlaying = true;
    updateSound();
    $('btnStart').disabled = true; $('btnStop').disabled = false;
};

$('btnStop').onclick = () => {
    stopAllSources();
    isPlaying = false;
    $('btnStart').disabled = false; $('btnStop').disabled = true;
    $('statusText').textContent = "已停止";
};

$('masterGain').oninput = function() { 
    if(gainNode) gainNode.gain.value = this.value; 
};

$('synthMode').onchange = function() {
    const val = this.value;
    
    $('harmonicControls').style.display = val === 'harmonic' ? 'block' : 'none';
    $('additiveControls').style.display = val === 'additive' ? 'block' : 'none';
    
    if (val === 'additive') {
        $('modeDesc').textContent = "混合大量正弦波，响度完全由曲线决定。波峰在哪，声音就在哪。";
    } else if (val === 'noise') {
        $('modeDesc').textContent = "基于曲线生成有色噪音 (高频=嘶嘶, 低频=轰隆)。";
    } else {
        $('modeDesc').textContent = "基于基频产生谐波，曲线决定谐波音量。";
    }
    
    if (isPlaying) updateSound();
};

$('freqStep').oninput = function() {
    $('stepVal').textContent = this.value + " Hz";
    if ($('synthMode').value === 'additive' && isPlaying) updateSound();
};

$('fundFreq').oninput = function() {
    $('freqVal').textContent = this.value + " Hz";
    if ($('synthMode').value === 'harmonic' && isPlaying) updateSound();
};

// --- 交互和 CSV 逻辑保持一致 ---
// 拖拽逻辑
const dropOverlay = $('dropOverlay');
window.addEventListener('dragover', e => { e.preventDefault(); dropOverlay.classList.add('active'); });
window.addEventListener('dragleave', e => { if (e.relatedTarget === null) dropOverlay.classList.remove('active'); });
window.addEventListener('drop', e => {
    e.preventDefault(); dropOverlay.classList.remove('active');
    if(e.dataTransfer.files && e.dataTransfer.files.length > 0) parseCSV(e.dataTransfer.files[0]);
});

function parseCSV(file) {
    const reader = new FileReader();
    reader.onload = (e) => {
        const text = e.target.result;
        const lines = text.split(/\r?\n/);
        let newPoints = [];
        let freqIdx = -1, ampIdx = -1;
        
        if(lines.length > 0) {
            const header = lines[0].toLowerCase().split(',');
            header.forEach((col, idx) => {
                if(col.includes('freq') || col.includes('hz')) freqIdx = idx;
                if(col.includes('amp') || col.includes('db') || col.includes('h1')) ampIdx = idx;
            });
        }
        if(freqIdx === -1 || ampIdx === -1) { freqIdx = 0; ampIdx = 1; }

        for(let i=1; i<lines.length; i++) {
            const cols = lines[i].split(',');
            if(cols.length < 2) continue;
            let f = parseFloat(cols[freqIdx]);
            let val = parseFloat(cols[ampIdx]);
            if(isNaN(f) || isNaN(val) || f < 0 || f > 40000) continue;

            let lin = val;
            if(val < 0) { lin = Math.pow(10, val / 20); }
            lin = Math.max(0, Math.min(1, lin));
            newPoints.push({f: f, a: lin});
        }

        if(newPoints.length > 0) {
            if(newPoints.length > 200) {
                const optimized = [];
                const step = Math.ceil(newPoints.length / 200);
                for(let i=0; i<newPoints.length; i+=step) optimized.push(newPoints[i]);
                if(optimized[optimized.length-1] !== newPoints[newPoints.length-1]) optimized.push(newPoints[newPoints.length-1]);
                newPoints = optimized;
            }

            points = newPoints;
            sortPoints();
            $('statusText').textContent = `已导入 CSV (${points.length} 点)`;
            draw();
            if (isPlaying) updateSound();
        } else {
            alert("无法解析 CSV 数据，请检查文件内容是否包含频率和幅度/dB数据。");
        }
    };
    reader.readAsText(file);
}

// 绘图交互逻辑（与上一版一致，略）
canvas.addEventListener('mousedown', e => {
    const r = canvas.getBoundingClientRect(); const x = e.clientX - r.left, y = e.clientY - r.top;
    if(e.button === 2) { isPanning = true; lastMouseX = e.clientX; return; }
    let hit = null, minD = 20;
    if(points.length < 100) { points.forEach(p => { const px = freqToX(p.f), py = ampToY(p.a); const d = Math.sqrt((x-px)**2 + (y-py)**2); if(d < minD) { minD = d; hit = p; } }); }
    if(hit) { activePoint = hit; isDragging = true; } else { const newP = { f: Math.max(0, xToFreq(x)), a: Math.max(0, Math.min(1, yToAmp(y))) }; points.push(newP); activePoint = newP; isDragging = true; sortPoints(); updateSound(); }
    draw();
});
window.addEventListener('mousemove', e => {
    if(isPanning) { const dx = e.clientX - lastMouseX; lastMouseX = e.clientX; const shift = -(dx/canvas.width)*(view.maxFreq - view.minFreq); view.minFreq = Math.max(0, view.minFreq+shift); view.maxFreq = Math.min(view.freqLimit, view.maxFreq+shift); draw(); return; }
    if(!isDragging || !activePoint) return;
    const r = canvas.getBoundingClientRect(); const f = Math.max(0, Math.min(view.freqLimit, xToFreq(e.clientX - r.left))); const a = Math.max(0, Math.min(1, yToAmp(e.clientY - r.top)));
    activePoint.f = parseFloat(f.toFixed(1)); activePoint.a = a; draw();
    if(isPlaying && !updateTimeout) { updateTimeout = setTimeout(() => { updateSound(); updateTimeout = null; }, 50); }
});
window.addEventListener('mouseup', () => { isDragging = false; isPanning = false; activePoint = null; if(isPlaying) updateSound(); });
canvas.addEventListener('dblclick', e => {
    const r = canvas.getBoundingClientRect(); const x = e.clientX - r.left, y = e.clientY - r.top; let hitIdx = -1, minD = 20;
    points.forEach((p,i) => { const d = Math.sqrt((x-freqToX(p.f))**2 + (y-ampToY(p.a))**2); if(d < minD) { minD = d; hitIdx = i; } });
    if(hitIdx >= 0 && points.length > 2) { points.splice(hitIdx, 1); draw(); updateSound(); }
});
canvas.addEventListener('wheel', e => { e.preventDefault(); const r = canvas.getBoundingClientRect(); const mF = xToFreq(e.clientX - r.left); const zoom = e.deltaY > 0 ? 1.1 : 0.9; const range = (view.maxFreq - view.minFreq) * zoom; const ratio = (mF - view.minFreq)/(view.maxFreq - view.minFreq); view.minFreq = Math.max(0, mF - range*ratio); view.maxFreq = Math.min(view.freqLimit, mF + range*(1-ratio)); draw(); }, {passive:false});
canvas.addEventListener('contextmenu', e => e.preventDefault());

resize();
</script>
</body>
</html>
