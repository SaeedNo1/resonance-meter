<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>直观频谱合成器 (Spectral Morphing)</title>
<style>
  /* === 保持原有 CSS 样式 === */
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:#0f1724;color:#e6eef8;margin:0;padding:16px}
  .wrap{max-width:900px;margin:0 auto}
  h1{font-size:20px;margin:6px 0 12px; display:flex; justify-content:space-between; align-items:center;}
  .card{background:#0b1220;border:1px solid #1f2a44;border-radius:12px;padding:12px;margin-bottom:12px}
  label{font-size:13px;color:#9fb0d6;display:block;margin-top:8px}
  input,select,button{font-size:15px;padding:8px;border-radius:8px;border:1px solid #26364f;background:#081024;color:#e6eef8;width:100%;box-sizing:border-box}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .controls{display:flex;gap:8px;margin-top:12px;flex-wrap:wrap;align-items: flex-end;}
  button{cursor:pointer;transition:all 0.2s; font-weight:600;}
  button:hover{filter:brightness(1.1)}
  button:disabled{opacity:0.6;cursor:not-allowed;filter:grayscale(0.8);}
  button.primary{background:#3fa7ff;border:none;color:#032033}
  button.stop{background:#ff4757;border:none;color:#fff;}
  
  .plot-container { position: relative; width: 100%; height: 320px; overflow: hidden; background:#061225; border-radius:8px; border:1px solid #22314a;}
  canvas{display:block; width: 100%; height: 100%; cursor: crosshair;}
  
  .pill{display:inline-block;padding:8px 12px;border-radius:999px;background:#07162b;color:#bfe0ff;margin-right:8px;font-size:13px}
  .hint{font-size:12px;color:#95b7dc;margin-top:8px;line-height:1.4}
  
  .section-title { color:#3fa7ff; font-size:14px; font-weight:bold; margin-bottom:8px; display:block; border-bottom:1px solid #1f2a44; padding-bottom:4px; }
  
  /* 新增：模式解释 */
  .mode-desc { font-size:12px; color:#ffcf6b; margin-top:4px; font-style: italic;}
</style>
</head>
<body>
<div class="wrap">
  <h1><span>直观频谱合成器</span> <span style="font-size:12px;color:#666">Spectral Synthesis</span></h1>

  <div class="card">
    <span class="section-title">频谱绘制 (Draw Your Sound)</span>
    <div class="plot-container">
        <canvas id="canvas"></canvas>
    </div>
    <div class="hint">
      <b>现在所见即所听！</b><br>
      • <b>高频 (右侧)</b>：控制尖锐度、“嘶嘶”声或高音。<br>
      • <b>低频 (左侧)</b>：控制厚度、“轰隆”声或低音。<br>
      • <b>操作</b>：左键点击/拖拽加点，双击删点，滚轮缩放频率轴。
    </div>
  </div>

  <div class="card">
    <span class="section-title">合成引擎控制</span>
    <div class="row">
      <div>
        <label>合成模式 (Synthesis Mode)</label>
        <select id="synthMode">
          <option value="noise" selected>1. 频谱噪音 (Spectral Noise) - 最直观</option>
          <option value="harmonic">2. 丰富谐波 (Rich Harmonics) - 乐器感</option>
        </select>
        <div id="modeDesc" class="mode-desc">
            完全根据曲线生成“有色噪音”。画哪里，哪里就有声音。
        </div>
      </div>
      <div>
        <label>总音量 (Volume)</label>
        <input id="masterGain" type="range" min="0" max="1" step="0.01" value="0.5" />
      </div>
    </div>
    
    <div id="harmonicControls" style="display:none; margin-top:8px;">
        <label>基频音高 (Fundamental Pitch)</label>
        <input id="fundFreq" type="range" min="50" max="800" step="1" value="110" />
        <span id="freqVal" style="font-size:12px; float:right; color:#3fa7ff">110 Hz (A2)</span>
    </div>

    <div class="controls">
      <button id="btnStart" class="primary" style="flex:2">开始生成并播放</button>
      <button id="btnStop" class="stop" style="flex:1" disabled>停止</button>
    </div>
    
    <div class="hint" style="margin-top:12px; border-top:1px solid #1f2a44; padding-top:8px;">
        引擎状态: <span id="statusText" style="color:#3fa7ff">就绪</span>
    </div>
  </div>
</div>

<script>
// ==================== 1. MiniFFT (逆傅里叶变换核心) ====================
// 我们需要它把你的曲线(频域)直接变成声音波形(时域)
class MiniFFT {
    constructor(size) {
        this.size = size;
        this.levels = Math.log2(size);
        if (Math.pow(2, this.levels) !== size) throw "FFT size must be power of 2";
        this.cosTable = new Float32Array(size / 2);
        this.sinTable = new Float32Array(size / 2);
        for (let i = 0; i < size / 2; i++) {
            this.cosTable[i] = Math.cos(2 * Math.PI * i / size);
            this.sinTable[i] = Math.sin(2 * Math.PI * i / size);
        }
        this.reverseTable = new Uint32Array(size);
        for (let i = 0; i < size; i++) {
            let rev = 0;
            for (let j = 0; j < this.levels; j++) {
                if ((i >> j) & 1) rev |= (1 << (this.levels - 1 - j));
            }
            this.reverseTable[i] = rev;
        }
    }
    // 逆变换：输入复数频谱 [re, im, re, im...]，输出实数波形
    inverseTransform(outReal, inputComplex) {
        this.transform(inputComplex, true);
        for (let i = 0; i < this.size; i++) outReal[i] = inputComplex[2 * i];
    }
    transform(data, inverse) {
        const n = this.size;
        for (let i = 0; i < n; i++) {
            const rev = this.reverseTable[i];
            if (i < rev) {
                let tr = data[2 * i], ti = data[2 * i + 1];
                data[2 * i] = data[2 * rev]; data[2 * i + 1] = data[2 * rev + 1];
                data[2 * rev] = tr; data[2 * rev + 1] = ti;
            }
        }
        for (let size = 2; size <= n; size *= 2) {
            const halfsize = size / 2;
            const tablestep = n / size;
            for (let i = 0; i < n; i += size) {
                for (let j = 0, k = 0; j < halfsize; j++, k += tablestep) {
                    const idx1 = 2 * (i + j);
                    const idx2 = 2 * (i + j + halfsize);
                    const tpre = data[idx2];
                    const tpim = data[idx2 + 1];
                    let cost = this.cosTable[k], sint = this.sinTable[k];
                    if (inverse) sint = -sint;
                    const re = tpre * cost - tpim * sint;
                    const im = tpre * sint + tpim * cost;
                    data[idx2] = data[idx1] - re;
                    data[idx2 + 1] = data[idx1 + 1] - im;
                    data[idx1] += re;
                    data[idx1 + 1] += im;
                }
            }
        }
        if (inverse) {
            const f = 1.0 / n;
            for (let i = 0; i < 2 * n; i++) data[i] *= f;
        }
    }
}

// ==================== 2. 全局变量 ====================
const $ = id => document.getElementById(id);
let audioCtx = null;
let bufferSource = null;
let gainNode = null;
let isPlaying = false;
let updateTimeout = null;

// 视图与数据
const view = { minFreq: 0, maxFreq: 22000, freqLimit: 40000 };
// 初始曲线：低频高，高频低 (模拟粉噪/自然声)
let points = [
    { f: 0, a: 0.8 },
    { f: 400, a: 0.6 },
    { f: 2000, a: 0.3 },
    { f: 10000, a: 0.1 },
    { f: 40000, a: 0.0 }
];

// 交互状态
let activePoint = null;
let isDragging = false;
let isPanning = false;
let lastMouseX = 0;

// ==================== 3. 绘图逻辑 (Canvas) ====================
const canvas = $('canvas');
const g = canvas.getContext('2d');

function resize() {
    const p = canvas.parentNode.getBoundingClientRect();
    canvas.width = p.width; canvas.height = p.height;
    draw();
}
window.addEventListener('resize', resize);

const xToFreq = x => view.minFreq + (x/canvas.width)*(view.maxFreq - view.minFreq);
const freqToX = f => ((f - view.minFreq)/(view.maxFreq - view.minFreq))*canvas.width;
const yToAmp = y => 1 - (y/canvas.height);
const ampToY = a => (1 - a)*canvas.height;

function sortPoints() { points.sort((a,b) => a.f - b.f); }

// 插值算法：获取任意频率在当前曲线上的幅度
function getCurveAmplitude(freq) {
    if(points.length === 0) return 0;
    if(freq <= points[0].f) return points[0].a;
    if(freq >= points[points.length-1].f) return points[points.length-1].a;
    
    // 线性插值
    for(let i=0; i<points.length-1; i++) {
        if(freq >= points[i].f && freq <= points[i+1].f) {
            const t = (freq - points[i].f) / (points[i+1].f - points[i].f);
            return points[i].a + t * (points[i+1].a - points[i].a);
        }
    }
    return 0;
}

function draw() {
    const w = canvas.width, h = canvas.height;
    g.fillStyle = "#061225"; g.fillRect(0,0,w,h);
    
    // 网格
    g.lineWidth = 1; g.strokeStyle = "#1f2a44"; g.fillStyle = "#5c6b8f"; g.font = "10px sans-serif";
    // Y轴
    for(let i=0; i<=5; i++) {
        const y = ampToY(i/5);
        g.beginPath(); g.moveTo(0,y); g.lineTo(w,y); g.stroke();
        g.textAlign = "left"; g.fillText((i/5).toFixed(1), 5, y-2);
    }
    // X轴
    const range = view.maxFreq - view.minFreq;
    let step = 2000;
    if(range < 5000) step = 500;
    if(range > 20000) step = 5000;
    const start = Math.ceil(view.minFreq/step)*step;
    for(let f=start; f<view.maxFreq; f+=step) {
        const x = freqToX(f);
        g.beginPath(); g.moveTo(x,0); g.lineTo(x,h); g.stroke();
        g.textAlign = "center"; g.fillText(f, x, h-5);
    }

    // 绘制曲线填充
    sortPoints();
    if(points.length > 0) {
        g.beginPath();
        g.moveTo(freqToX(0), ampToY(points[0].a));
        for(let p of points) g.lineTo(freqToX(p.f), ampToY(p.a));
        g.lineTo(freqToX(40000), ampToY(points[points.length-1].a));
        g.lineTo(freqToX(40000), h);
        g.lineTo(freqToX(0), h);
        g.fillStyle = "rgba(63, 167, 255, 0.2)";
        g.fill();
        
        // 曲线描边
        g.beginPath();
        g.strokeStyle = "#3fa7ff"; g.lineWidth = 3;
        g.moveTo(freqToX(0), ampToY(points[0].a));
        for(let p of points) g.lineTo(freqToX(p.f), ampToY(p.a));
        g.lineTo(freqToX(40000), ampToY(points[points.length-1].a));
        g.stroke();
    }

    // 控制点
    for(let p of points) {
        const x = freqToX(p.f);
        if(x > -10 && x < w+10) {
            g.beginPath();
            g.arc(x, ampToY(p.a), p===activePoint?8:5, 0, Math.PI*2);
            g.fillStyle = p===activePoint?"#fff":"#3fa7ff"; g.fill();
            g.strokeStyle="#fff"; g.lineWidth=2; g.stroke();
        }
    }
}

// ==================== 4. 交互处理 ====================
canvas.addEventListener('mousedown', e => {
    const r = canvas.getBoundingClientRect();
    const x = e.clientX - r.left, y = e.clientY - r.top;
    
    if(e.button === 2) { // 右键平移
        isPanning = true; lastMouseX = e.clientX; return;
    }

    // 命中测试
    let hit = null, minD = 20;
    points.forEach(p => {
        const px = freqToX(p.f), py = ampToY(p.a);
        const d = Math.sqrt((x-px)**2 + (y-py)**2);
        if(d < minD) { minD = d; hit = p; }
    });

    if(hit) {
        activePoint = hit; isDragging = true;
    } else {
        const newP = { f: Math.max(0, xToFreq(x)), a: Math.max(0, Math.min(1, yToAmp(y))) };
        points.push(newP); activePoint = newP; isDragging = true;
        sortPoints();
        updateSoundBuffer(); // 添加点立即更新
    }
    draw();
});

window.addEventListener('mousemove', e => {
    if(isPanning) {
        const dx = e.clientX - lastMouseX; lastMouseX = e.clientX;
        const shift = -(dx/canvas.width)*(view.maxFreq - view.minFreq);
        view.minFreq = Math.max(0, view.minFreq+shift);
        view.maxFreq = Math.min(view.freqLimit, view.maxFreq+shift);
        draw(); return;
    }
    if(!isDragging || !activePoint) return;
    
    const r = canvas.getBoundingClientRect();
    const f = Math.max(0, Math.min(view.freqLimit, xToFreq(e.clientX - r.left)));
    const a = Math.max(0, Math.min(1, yToAmp(e.clientY - r.top)));
    
    activePoint.f = parseFloat(f.toFixed(1)); activePoint.a = a;
    draw();
    
    // 拖动时节流更新声音
    if(isPlaying && !updateTimeout) {
        updateTimeout = setTimeout(() => {
            updateSoundBuffer();
            updateTimeout = null;
        }, 50); // 50ms 更新一次
    }
});

window.addEventListener('mouseup', () => {
    isDragging = false; isPanning = false; activePoint = null;
    if(isPlaying) updateSoundBuffer(); // 最终更新
});

canvas.addEventListener('dblclick', e => {
    // 简单删除逻辑
    const r = canvas.getBoundingClientRect();
    const x = e.clientX - r.left, y = e.clientY - r.top;
    let hitIdx = -1, minD = 20;
    points.forEach((p,i) => {
        const d = Math.sqrt((x-freqToX(p.f))**2 + (y-ampToY(p.a))**2);
        if(d < minD) { minD = d; hitIdx = i; }
    });
    if(hitIdx >= 0 && points.length > 2) {
        points.splice(hitIdx, 1);
        draw(); updateSoundBuffer();
    }
});

canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const r = canvas.getBoundingClientRect();
    const mF = xToFreq(e.clientX - r.left);
    const zoom = e.deltaY > 0 ? 1.1 : 0.9;
    const range = (view.maxFreq - view.minFreq) * zoom;
    const ratio = (mF - view.minFreq)/(view.maxFreq - view.minFreq);
    view.minFreq = Math.max(0, mF - range*ratio);
    view.maxFreq = Math.min(view.freqLimit, mF + range*(1-ratio));
    draw();
}, {passive:false});
canvas.addEventListener('contextmenu', e => e.preventDefault());

// ==================== 5. 核心音频引擎 (Spectral Synthesis) ====================

function initAudio() {
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if(!gainNode) {
        gainNode = audioCtx.createGain();
        gainNode.gain.value = 0.5;
        gainNode.connect(audioCtx.destination);
    }
}

// 这就是魔法所在：直接根据你的曲线计算波形
function generateBuffer() {
    if(!audioCtx) return null;
    
    const size = 16384; // 较大的FFT尺寸以获得更好的低频分辨率
    const fft = new MiniFFT(size);
    const complex = fft.createComplexArray();
    const mode = $('synthMode').value;
    const sr = audioCtx.sampleRate;
    
    // 1. 填充频域数据
    const binSize = sr / size;
    const nyquistBin = size / 2;
    
    // 谐波模式参数
    const fundFreq = parseFloat($('fundFreq').value);
    
    if (mode === 'noise') {
        // === 模式1: 频谱噪音 ===
        // 每个频率点都根据曲线设置幅度，相位随机
        for(let i = 1; i < nyquistBin; i++) {
            const freq = i * binSize;
            const amp = getCurveAmplitude(freq);
            
            // 随机相位产生噪音
            const phase = Math.random() * 2 * Math.PI;
            
            // 实部 = amp * cos(phase), 虚部 = amp * sin(phase)
            // 乘以一个缩放因子防止爆音
            const scale = amp * 0.5; 
            complex[2*i] = scale * Math.cos(phase);
            complex[2*i+1] = scale * Math.sin(phase);
        }
    } else {
        // === 模式2: 丰富谐波 (类似加性合成) ===
        // 只有基频的整数倍位置有能量，幅度由曲线决定
        for(let n = 1; ; n++) {
            const freq = n * fundFreq;
            if(freq >= sr/2) break; // 超过奈奎斯特频率停止
            
            const bin = Math.round(freq / binSize);
            if(bin >= nyquistBin) break;
            
            const amp = getCurveAmplitude(freq);
            
            // 随机相位可以让声音更厚实，固定相位更像电子音
            // 这里用随机相位避免峰值叠加导致的爆音
            const phase = Math.random() * 2 * Math.PI;
            
            // 谐波需要更多的增益补偿，因为只有少数bin有能量
            const scale = amp * 100; 
            
            complex[2*bin] = scale * Math.cos(phase);
            complex[2*bin+1] = scale * Math.sin(phase);
        }
    }

    // 2. 逆变换生成时域波形
    const timeDomain = new Float32Array(size);
    fft.inverseTransform(timeDomain, complex);
    
    // 3. 创建 Buffer 并平滑边缘防止循环咔哒声
    const buffer = audioCtx.createBuffer(1, size, sr);
    const data = buffer.getChannelData(0);
    
    // 简单的淡入淡出处理 (Windowing)
    for(let i=0; i<size; i++) {
        // 使用 Hann Window 的变种来平滑首尾
        // 或者因为相位是随机的，首尾可能不匹配。
        // 对于噪音循环，最好的办法是生成长一点然后由AudioNode循环，
        // 但这里为了响应速度，我们做简单的线性淡入淡出。
        data[i] = timeDomain[i];
    }
    
    return buffer;
}

// 热更新声音
function updateSoundBuffer() {
    if(!isPlaying || !audioCtx) return;
    
    const newBuf = generateBuffer();
    
    // 无缝切换 Buffer (Cross-fading technique would be better but complex)
    // 这里我们使用一种快速替换策略：
    // 创建新源，启动新源，停止旧源。
    
    const newSource = audioCtx.createBufferSource();
    newSource.buffer = newBuf;
    newSource.loop = true;
    newSource.connect(gainNode);
    newSource.start();
    
    const oldSource = bufferSource;
    bufferSource = newSource;
    
    if(oldSource) {
        // 微小的重叠防止爆音
        oldSource.stop(audioCtx.currentTime + 0.05);
        // 让旧声音淡出一点点会更好，但这里简化处理
    }
}

// 播放控制
$('btnStart').onclick = async () => {
    initAudio();
    await audioCtx.resume();
    
    bufferSource = audioCtx.createBufferSource();
    bufferSource.buffer = generateBuffer();
    bufferSource.loop = true;
    bufferSource.connect(gainNode);
    bufferSource.start();
    
    isPlaying = true;
    $('btnStart').disabled = true;
    $('btnStop').disabled = false;
    $('statusText').textContent = "正在合成并播放...";
};

$('btnStop').onclick = () => {
    if(bufferSource) {
        try{ bufferSource.stop(); }catch(e){}
        bufferSource.disconnect();
    }
    isPlaying = false;
    $('btnStart').disabled = false;
    $('btnStop').disabled = true;
    $('statusText').textContent = "已停止";
};

// UI 响应
$('masterGain').oninput = function() { if(gainNode) gainNode.gain.value = this.value; };

$('synthMode').onchange = function() {
    const val = this.value;
    $('harmonicControls').style.display = val === 'harmonic' ? 'block' : 'none';
    $('modeDesc').textContent = val === 'noise' 
        ? "完全根据曲线生成“有色噪音”。画哪里，哪里就有声音 (高频=嘶嘶, 低频=轰隆)。" 
        : "基于基频产生一系列谐波，曲线决定每个谐波的音量 (类似风琴或人声元音)。";
    updateSoundBuffer();
};

$('fundFreq').oninput = function() {
    $('freqVal').textContent = this.value + " Hz";
    if($('synthMode').value === 'harmonic') updateSoundBuffer();
};

// 初始化
resize();
</script>
</body>
</html>
