<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>专业共振频率扫测仪 (CSV导入版)</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:#0f1724;color:#e6eef8;margin:0;padding:16px; min-height: 100vh;}
  .wrap{max-width:900px;margin:0 auto; position: relative; z-index: 1;}
  h1{font-size:20px;margin:6px 0 12px; display:flex; justify-content:space-between; align-items:center;}
  .card{background:#0b1220;border:1px solid #1f2a44;border-radius:12px;padding:12px;margin-bottom:12px; position:relative;}
  label{font-size:13px;color:#9fb0d6;display:block;margin-top:8px}
  input,select,button{font-size:15px;padding:8px;border-radius:8px;border:1px solid #26364f;background:#081024;color:#e6eef8;width:100%;box-sizing:border-box}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .controls{display:flex;gap:8px;margin-top:12px;flex-wrap:wrap;align-items: flex-end;}
  button{cursor:pointer;transition:all 0.2s; font-weight:600;}
  button:hover{filter:brightness(1.1)}
  button:disabled{opacity:0.6;cursor:not-allowed;filter:grayscale(0.8);}
  button.primary{background:#3fa7ff;border:none;color:#032033}
  button.stop{background:#ff4757;border:none;color:#fff;}
  
  /* 图表容器 */
  .plot-container { position: relative; width: 100%; height: 300px; overflow: hidden; background:#061225; border-radius:8px; border:1px solid #22314a;}
  canvas{display:block; width: 100%; height: 100%; cursor: crosshair;}
  
  .pill{display:inline-block;padding:8px 12px;border-radius:999px;background:#07162b;color:#bfe0ff;margin-right:8px;font-size:13px}
  .hint{font-size:12px;color:#95b7dc;margin-top:8px;line-height:1.4}
  a{color:#82c1ff}
  #hud{font-family:monospace; color:#0f0; margin-top:10px; font-size:14px;}
  #essReport{margin-top:10px; padding:10px; background:#111; color:#0f0; font-family:monospace; border-radius:6px; overflow-x:auto; border:1px solid #333;}
  .checkbox-group { display:flex; gap:12px; margin-top:8px; align-items:center; flex-wrap:wrap;}
  .checkbox-group label { margin:0; cursor:pointer; display:flex; align-items:center; gap:4px; color:#fff;}
  
  /* 专用样式 */
  .section-title { color:#3fa7ff; font-size:14px; font-weight:bold; margin-bottom:8px; display:block; border-bottom:1px solid #1f2a44; padding-bottom:4px; }
  .mode-select { border: 1px solid #3fa7ff; background: #0c1a30; color: #3fa7ff; font-weight: bold; }

  /* 拖拽覆盖层 */
  #dropOverlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(63, 167, 255, 0.15);
    border: 4px dashed #3fa7ff;
    z-index: 9999;
    display: none;
    pointer-events: none;
    justify-content: center; align-items: center;
    color: #3fa7ff; font-size: 24px; font-weight: bold;
    backdrop-filter: blur(2px);
  }
  #dropOverlay.active { display: flex; }
</style>
</head>
<body>

<div id="dropOverlay">松开鼠标导入测试数据 CSV</div>

<div class="wrap">
  <h1><span>固有频率扫测仪 Pro</span> <span style="font-size:12px;color:#666">v2.1 CSV版</span></h1>

  <div class="card">
    <div class="row">
      <div>
        <label>起始频率 (Hz)</label>
        <input id="fStart" type="number" value="50" step="1" min="1" />
      </div>
      <div>
        <label>终止频率 (Hz)</label>
        <input id="fEnd" type="number" value="2000" step="1" min="1" />
      </div>
    </div>

    <div style="background:#131e33; padding:10px; border-radius:8px; margin-top:10px;">
        <label style="margin-top:0">算法模式</label>
        <select id="algoMode" class="mode-select">
            <option value="step">Discrete Step (步进扫频 - 慢速，直观)</option>
            <option value="ess" selected>ESS (指数正弦扫 - 快速，高精度)</option>
        </select>
        
        <div id="stepParams" class="row" style="margin-top:8px; display:none;">
            <div><label>步数 (Steps)</label><input id="steps" type="number" value="80" min="2" /></div>
            <div><label>每步时长 (ms)</label><input id="dur" type="number" value="120" min="20" /></div>
            <div style="grid-column: span 2;">
                <label>波形</label>
                <select id="wave">
                    <option value="sine">正弦波 (Sine)</option>
                    <option value="triangle">三角波</option>
                    <option value="square">方波</option>
                </select>
            </div>
        </div>

        <div id="essParams" class="row" style="margin-top:8px;">
            <div><label>扫频时长 (s)</label><input id="essDur" type="number" value="10" step="1" min="1" /></div>
            <div>
                 <label>谐波展示</label>
                 <div class="checkbox-group" style="margin-top:12px;">
                    <label><input type="checkbox" class="hToggle" value="1" checked> H1</label>
                    <label><input type="checkbox" class="hToggle" value="2" checked> H2</label>
                    <label><input type="checkbox" class="hToggle" value="3"> H3</label>
                 </div>
            </div>
        </div>
    </div>
    
    <label>播放音量 (Gain 0-1)</label>
    <input id="gain" type="range" min="0" max="1" step="0.01" value="0.8" />

    <div class="controls">
      <button id="mainBtn" class="primary" style="flex:2;">开始测试</button>
      <button id="stopBtn" class="stop" style="flex:1;" disabled>停止</button>
      <button id="exportCSV" style="flex:1;">导出数据</button>
      <button onclick="location.href='Frequency.html'">准备共振</button>
    </div>

    <div id="hud">
      频率: <span id="hudFreq">—</span> Hz | 进度: <span id="hudProg">0</span>%
    </div>
    
    <div style="margin-top:10px">
      <span class="pill">峰值频率：<span id="peakFreq">—</span> Hz</span>
      <span class="pill">峰值幅度：<span id="peakAmp">—</span></span>
    </div>

    <div class="hint">
      提示：<b>可直接将导出的 CSV 文件拖入此页面进行回放分析。</b><br>
      鼠标滚轮可缩放图表，拖拽可移动视图。双击图表复位。
    </div>
  </div>

  <div class="card">
    <span class="section-title">频响曲线 (Frequency Response)</span>
    <div class="plot-container">
        <canvas id="plot"></canvas>
    </div>
  </div>
  
  <div id="essReport" style="display:none;">
    <b>分析报告：</b>
    <pre id="essReportText">...</pre>
  </div>

  <div class="card">
    <span class="section-title">脉冲/敲击检测 (Impulse Detection)</span>
    <div class="controls" style="margin-top:0; margin-bottom:8px;">
      <button id="tapDetectBtn" style="width:auto;">开始敲击录音 (2s)</button>
      <label style="display:inline-flex;align-items:center;margin:0 0 0 10px;">
        <input type="checkbox" id="enableHPF" checked style="width:auto;margin-right:4px;"> 高通滤波 (>50Hz)
      </label>
      <a id="downloadTap" style="display:none; margin-left:auto; line-height:36px;" href="#">下载录音</a>
    </div>
    <div style="margin-bottom:8px;">
        <span class="pill">基频估算: <span id="tapFreq">—</span> Hz</span>
    </div>
    <div class="plot-container" style="height:150px;">
        <canvas id="tapWave"></canvas>
    </div>
  </div>
</div>

<script>
// ==================== 0. 内嵌 MiniFFT 库 ====================
// 一个自包含的 Radix-2 FFT 实现，用于替代缺失的外部库
class MiniFFT {
    constructor(size) {
        this.size = size;
        this.levels = Math.log2(size);
        if (Math.pow(2, this.levels) !== size) throw "FFT size must be power of 2";
        this.cosTable = new Float32Array(size / 2);
        this.sinTable = new Float32Array(size / 2);
        for (let i = 0; i < size / 2; i++) {
            this.cosTable[i] = Math.cos(2 * Math.PI * i / size);
            this.sinTable[i] = Math.sin(2 * Math.PI * i / size);
        }
        this.reverseTable = new Uint32Array(size);
        for (let i = 0; i < size; i++) {
            let rev = 0;
            for (let j = 0; j < this.levels; j++) {
                if ((i >> j) & 1) rev |= (1 << (this.levels - 1 - j));
            }
            this.reverseTable[i] = rev;
        }
    }

    // 创建复数数组 [re, im, re, im...]
    createComplexArray() { return new Float32Array(this.size * 2); }

    // 实数转复数 FFT
    realTransform(out, input) {
        for (let i = 0; i < this.size; i++) {
            out[2 * i] = input[i];
            out[2 * i + 1] = 0;
        }
        this.transform(out, false);
    }

    // 复数逆变换
    inverseTransform(outReal, inputComplex) {
        this.transform(inputComplex, true);
        for (let i = 0; i < this.size; i++) {
            outReal[i] = inputComplex[2 * i]; // 已经缩放
        }
    }

    transform(data, inverse) {
        const n = this.size;
        // Bit-reverse copy
        for (let i = 0; i < n; i++) {
            const rev = this.reverseTable[i];
            if (i < rev) {
                let tr = data[2 * i], ti = data[2 * i + 1];
                data[2 * i] = data[2 * rev]; data[2 * i + 1] = data[2 * rev + 1];
                data[2 * rev] = tr; data[2 * rev + 1] = ti;
            }
        }

        // Cooley-Tukey
        for (let size = 2; size <= n; size *= 2) {
            const halfsize = size / 2;
            const tablestep = n / size;
            for (let i = 0; i < n; i += size) {
                for (let j = 0, k = 0; j < halfsize; j++, k += tablestep) {
                    const idx1 = 2 * (i + j);
                    const idx2 = 2 * (i + j + halfsize);
                    const tpre = data[idx2];
                    const tpim = data[idx2 + 1];
                    
                    // Trigonometric values
                    let cost = this.cosTable[k];
                    let sint = this.sinTable[k];
                    if (inverse) sint = -sint;

                    const re = tpre * cost - tpim * sint;
                    const im = tpre * sint + tpim * cost;

                    data[idx2] = data[idx1] - re;
                    data[idx2 + 1] = data[idx1 + 1] - im;
                    data[idx1] += re;
                    data[idx1 + 1] += im;
                }
            }
        }
        
        // Normalize for inverse
        if (inverse) {
            const f = 1.0 / n;
            for (let i = 0; i < 2 * n; i++) data[i] *= f;
        }
    }
}

// ==================== 1. 全局状态与工具 ====================
const $ = id => document.getElementById(id);
let audioCtx = null;
let micStream = null;
let currentOsc = null;
let currentSource = null;
let isRunning = false;

// 数据存储
let globalData = {
    type: null, // 'step' or 'ess'
    stepData: [],
    essResults: null,
    fStart: 0,
    fEnd: 0
};
let tapDataRaw = null; // 敲击波形数据

// 图表视图状态 (用于缩放和平移)
const chartView = {
    freq: { min: 0, max: 0 }, // 当前显示的频率范围
    db: { min: -100, max: 0 },
    isDragging: false,
    lastX: 0
};
const tapView = {
    offset: 0,
    zoom: 1, // 1 = fit all
    isDragging: false,
    lastX: 0
};

// 工具函数
const sleep = ms => new Promise(r => setTimeout(r, ms));
function getRMS(buf) {
    let s = 0; for(let x of buf) s += x*x; return Math.sqrt(s/buf.length);
}
function getAudioCtx() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    return audioCtx;
}

// ==================== 2. UI 逻辑与交互 ====================

// 模式切换
$('algoMode').addEventListener('change', (e) => {
    const mode = e.target.value;
    $('stepParams').style.display = mode === 'step' ? 'grid' : 'none';
    $('essParams').style.display = mode === 'ess' ? 'grid' : 'none';
});

// 按钮控制
$('mainBtn').addEventListener('click', async () => {
    if (isRunning) return;
    const mode = $('algoMode').value;
    
    // UI 状态
    setRunningUI(true);
    
    try {
        if (mode === 'step') await runStepSweep();
        else await runESS();
    } catch (e) {
        if (e.message !== 'Aborted') alert("错误: " + e.message);
    } finally {
        setRunningUI(false);
    }
});

$('stopBtn').addEventListener('click', () => {
    isRunning = false;
    if (currentOsc) { try{currentOsc.stop();}catch(e){} currentOsc = null; }
    if (currentSource) { try{currentSource.stop();}catch(e){} currentSource = null; }
    if (micStream) { micStream.getTracks().forEach(t=>t.stop()); micStream = null; }
    setRunningUI(false);
});

function setRunningUI(active) {
    isRunning = active;
    $('mainBtn').disabled = active;
    $('stopBtn').disabled = !active;
    $('algoMode').disabled = active;
    
    if (active) {
        let sec = 0;
        $('mainBtn').dataset.timer = setInterval(() => {
            sec += 0.1;
            $('mainBtn').textContent = `运行中 (${sec.toFixed(1)}s)`;
        }, 100);
    } else {
        clearInterval($('mainBtn').dataset.timer);
        $('mainBtn').textContent = "开始测试";
        $('hudFreq').textContent = "—";
    }
}

// ==================== CSV 拖拽导入逻辑 ====================
const dropOverlay = $('dropOverlay');

window.addEventListener('dragover', e => { e.preventDefault(); dropOverlay.classList.add('active'); });
window.addEventListener('dragleave', e => { 
    if (e.relatedTarget === null) dropOverlay.classList.remove('active'); 
});
window.addEventListener('drop', e => {
    e.preventDefault();
    dropOverlay.classList.remove('active');
    
    if(e.dataTransfer.files && e.dataTransfer.files.length > 0) {
        parseImportCSV(e.dataTransfer.files[0]);
    }
});

function parseImportCSV(file) {
    const reader = new FileReader();
    reader.onload = (e) => {
        const text = e.target.result;
        const lines = text.trim().split(/\r?\n/);
        if (lines.length < 2) return alert("无效的 CSV 文件");

        // 简单的启发式判断格式
        // 步进格式头: Freq(Hz),Amp(dB) 或类似
        // ESS格式头: Freq(Hz),H1(dB),H2(dB)...
        const header = lines[0].toLowerCase();
        const isEss = header.includes("h1") || header.includes("h2");
        const isStep = !isEss && (header.includes("amp") || header.includes("db") || lines[0].split(',').length === 2);

        if (!isEss && !isStep) {
            return alert("无法识别 CSV 格式，请使用本工具导出的文件。");
        }

        let fMin = Infinity, fMax = -Infinity;

        if (isStep) {
            // 解析 Step Sweep 数据
            globalData.type = 'step';
            globalData.stepData = [];
            
            // 找列索引
            const hParts = lines[0].split(',');
            let fIdx = 0, aIdx = 1; // 默认
            hParts.forEach((h, i) => {
                if(h.toLowerCase().includes('freq')) fIdx = i;
                if(h.toLowerCase().includes('amp') || h.toLowerCase().includes('db')) aIdx = i;
            });

            for(let i=1; i<lines.length; i++) {
                const parts = lines[i].split(',');
                if(parts.length < 2) continue;
                const f = parseFloat(parts[fIdx]);
                const db = parseFloat(parts[aIdx]);
                
                if(!isNaN(f) && !isNaN(db)) {
                    globalData.stepData.push({f, db});
                    if(f < fMin) fMin = f;
                    if(f > fMax) fMax = f;
                }
            }
        } else {
            // 解析 ESS 数据
            globalData.type = 'ess';
            globalData.essResults = {};
            
            const hParts = lines[0].split(',');
            const colMap = {};
            let fIdx = 0;
            
            hParts.forEach((h, i) => {
                const clean = h.toUpperCase();
                if(clean.includes('FREQ')) fIdx = i;
                if(clean.includes('H1')) colMap[1] = i;
                if(clean.includes('H2')) colMap[2] = i;
                if(clean.includes('H3')) colMap[3] = i;
                if(clean.includes('H4')) colMap[4] = i;
            });

            // 初始化
            Object.keys(colMap).forEach(k => globalData.essResults[k] = {freqs:[], amps:[]});

            for(let i=1; i<lines.length; i++) {
                const parts = lines[i].split(',');
                const f = parseFloat(parts[fIdx]);
                if(isNaN(f)) continue;
                if(f < fMin) fMin = f;
                if(f > fMax) fMax = f;

                Object.entries(colMap).forEach(([harm, colIdx]) => {
                    const db = parseFloat(parts[colIdx]);
                    if(!isNaN(db)) {
                        globalData.essResults[harm].freqs.push(f);
                        globalData.essResults[harm].amps.push(db);
                    }
                });
            }
        }

        // 更新 UI
        if(fMin !== Infinity && fMax !== -Infinity) {
            globalData.fStart = fMin;
            globalData.fEnd = fMax;
            $('fStart').value = fMin;
            $('fEnd').value = fMax;
            
            // 切换到对应模式 UI
            $('algoMode').value = globalData.type;
            $('algoMode').dispatchEvent(new Event('change'));
            
            // 重置视图
            resetChartView(fMin, fMax);
            
            // 分析峰值
            analyzePeak();
            
            // 绘图
            drawMainChart();
            
            // 提示
            $('hudFreq').textContent = "—"; // Reset HUD
            $('essReportText').textContent = "CSV 数据已导入并加载。";
            alert(`成功导入 ${globalData.type === 'step' ? '步进扫频' : 'ESS'} 数据。`);
        } else {
            alert("导入失败：未找到有效数据。");
        }
    };
    reader.readAsText(file);
}


// ==================== 3. 算法核心：Step Sweep ====================
async function runStepSweep() {
    const ctx = getAudioCtx();
    await ctx.resume();
    
    const fStart = parseFloat($('fStart').value);
    const fEnd = parseFloat($('fEnd').value);
    const steps = parseInt($('steps').value);
    const dur = parseFloat($('dur').value);
    const wave = $('wave').value;
    const gainVal = parseFloat($('gain').value);

    // 重置数据
    globalData.type = 'step';
    globalData.stepData = [];
    globalData.fStart = fStart;
    globalData.fEnd = fEnd;
    resetChartView(fStart, fEnd); // 重置视图

    // 麦克风
    micStream = await navigator.mediaDevices.getUserMedia({audio: {echoCancellation:false, noiseSuppression:false, autoGainControl:false}});
    const micSrc = ctx.createMediaStreamSource(micStream);
    const analyser = ctx.createAnalyser();
    analyser.fftSize = 2048;
    micSrc.connect(analyser);
    const timeData = new Float32Array(analyser.fftSize);

    // 输出
    const gainNode = ctx.createGain();
    gainNode.gain.value = gainVal;
    gainNode.connect(ctx.destination);

    // 生成频率表 (对数分布)
    const freqs = [];
    for(let i=0; i<steps; i++) freqs.push(fStart * Math.pow(fEnd/fStart, i/(steps-1)));

    for(let i=0; i<freqs.length; i++) {
        if(!isRunning) break;
        const f = freqs[i];
        
        // HUD
        $('hudFreq').textContent = f.toFixed(1);
        $('hudProg').textContent = Math.round(i/steps*100);

        // 发声
        currentOsc = ctx.createOscillator();
        currentOsc.type = wave;
        currentOsc.frequency.value = f;
        currentOsc.connect(gainNode);
        currentOsc.start();

        // 测量
        const stableT = Math.max(10, dur * 0.4); 
        await sleep(stableT);
        
        let sum = 0, cnt = 0;
        const endT = performance.now() + (dur - stableT);
        while(performance.now() < endT) {
            analyser.getFloatTimeDomainData(timeData);
            sum += getRMS(timeData);
            cnt++;
            await sleep(5);
        }

        currentOsc.stop();
        currentOsc.disconnect();
        currentOsc = null;

        // 记录 dB
        const avgRms = cnt ? sum/cnt : 0;
        const db = 20 * Math.log10(avgRms + 1e-9);
        globalData.stepData.push({f, db});
        
        drawMainChart();
        await sleep(10);
    }
    
    analyzePeak();
}

// ==================== 4. 算法核心：ESS (Exponential Sine Sweep) ====================

// 4.1 生成 ESS 信号与逆滤波器
function generateESS(f1, f2, dur, sr) {
    const N = Math.floor(dur * sr);
    const w1 = 2*Math.PI*f1;
    const w2 = 2*Math.PI*f2;
    const R = Math.log(w2/w1);
    const K = dur * w1 / R;
    const L = dur / R;

    const sweep = new Float32Array(N);
    const inv = new Float32Array(N);
    
    for(let n=0; n<N; n++) {
        const t = n/sr;
        // x(t) = sin(K * (exp(t/L) - 1))
        const phase = K * (Math.exp(t/L) - 1);
        sweep[n] = Math.sin(phase);
        
        // Inverse filter generation (Time reversed + Amplitude modulated)
        const tRev = (N - 1 - n) / sr;
        const mod = Math.exp(-tRev / L); 
        inv[n] = sweep[N - 1 - n] * mod;
    }
    
    // Normalize inverse
    let maxI = 0; for(let v of inv) maxI = Math.max(maxI, Math.abs(v));
    for(let i=0; i<N; i++) inv[i] /= maxI;

    return { sweep, inv };
}

// 4.2 卷积 (Convolution) 使用 MiniFFT
function convolve(signal, filter) {
    const len = signal.length + filter.length - 1;
    let fftSize = 1;
    while(fftSize < len) fftSize *= 2;
    
    const fft = new MiniFFT(fftSize);
    
    const sigPad = new Float32Array(fftSize);
    const filtPad = new Float32Array(fftSize);
    sigPad.set(signal);
    filtPad.set(filter); 
    
    const sigC = fft.createComplexArray();
    const filtC = fft.createComplexArray();
    
    fft.realTransform(sigC, sigPad);
    fft.realTransform(filtC, filtPad);
    
    // Complex Multiply
    const resC = fft.createComplexArray();
    for(let i=0; i<fftSize; i++) {
        const r1=sigC[2*i], i1=sigC[2*i+1];
        const r2=filtC[2*i], i2=filtC[2*i+1];
        resC[2*i] = r1*r2 - i1*i2;
        resC[2*i+1] = r1*i2 + i1*r2;
    }
    
    const result = new Float32Array(fftSize);
    fft.inverseTransform(result, resC);
    
    return result;
}

// 4.3 运行 ESS
async function runESS() {
    const ctx = getAudioCtx();
    await ctx.resume();
    
    const fStart = parseFloat($('fStart').value);
    const fEnd = parseFloat($('fEnd').value);
    const dur = parseFloat($('essDur').value);
    const gainVal = parseFloat($('gain').value);
    const sr = ctx.sampleRate;
    
    globalData.type = 'ess';
    globalData.fStart = fStart;
    globalData.fEnd = fEnd;
    globalData.essResults = null;
    $('essReport').style.display = 'block';
    $('essReportText').textContent = "正在生成信号...";
    
    // 1. 生成
    const { sweep, inv } = generateESS(fStart, fEnd, dur, sr);
    
    // 2. 准备录音
    micStream = await navigator.mediaDevices.getUserMedia({audio: {echoCancellation:false, noiseSuppression:false, autoGainControl:false}});
    const mime = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') ? 'audio/webm;codecs=opus' : 'audio/webm';
    const recorder = new MediaRecorder(micStream, {mimeType: mime});
    const chunks = [];
    recorder.ondataavailable = e => chunks.push(e.data);
    
    // 3. 播放与录制
    recorder.start();
    await sleep(200); // 录音机预热
    
    const buf = ctx.createBuffer(1, sweep.length, sr);
    buf.copyToChannel(sweep, 0);
    const src = ctx.createBufferSource();
    src.buffer = buf;
    const gn = ctx.createGain();
    gn.gain.value = gainVal;
    src.connect(gn);
    gn.connect(ctx.destination);
    
    currentSource = src;
    src.start();
    
    const t0 = ctx.currentTime;
    const hudTimer = setInterval(() => {
        if(!isRunning) return clearInterval(hudTimer);
        const el = ctx.currentTime - t0;
        const p = Math.min(100, el/dur*100);
        $('hudProg').textContent = p.toFixed(0);
        if(el <= dur) {
             $('hudFreq').textContent = (fStart * Math.pow(fEnd/fStart, el/dur)).toFixed(1);
        }
    }, 100);
    
    // 等待播放 + 混响
    await sleep(dur*1000 + 1000);
    clearInterval(hudTimer);
    if(currentSource) { currentSource.stop(); currentSource = null; }
    recorder.stop();
    
    $('essReportText').textContent = "正在处理卷积 (这可能需要几秒钟)...";
    await new Promise(r => recorder.onstop = r);
    micStream.getTracks().forEach(t=>t.stop()); micStream = null;
    
    if(!isRunning) return; // aborted

    // 4. 数据处理
    const blob = new Blob(chunks, {type: mime});
    const ab = await blob.arrayBuffer();
    const audioB = await ctx.decodeAudioData(ab);
    const recData = audioB.getChannelData(0);
    
    // 卷积
    const ir = convolve(recData, inv);
    
    // 5. 谐波分析 (提取 IR 中的脉冲)
    analyzeEssHarmonics(ir, sr, fStart, fEnd, dur);
}

function analyzeEssHarmonics(ir, sr, f1, f2, dur) {
    let maxVal = 0, maxIdx = 0;
    for(let i=0; i<ir.length; i++) {
        if(Math.abs(ir[i]) > maxVal) { maxVal = Math.abs(ir[i]); maxIdx = i; }
    }
    
    const harmonics = [1, 2, 3];
    const results = {};
    const fftSize = 4096;
    const fft = new MiniFFT(fftSize);
    const freqLogBase = Math.log(f2/f1);

    harmonics.forEach(h => {
        const dt = dur * Math.log(h) / freqLogBase;
        const offset = Math.round(dt * sr);
        const center = maxIdx - offset;
        
        const seg = new Float32Array(fftSize);
        if(center - fftSize/2 >= 0 && center + fftSize/2 < ir.length) {
            for(let i=0; i<fftSize; i++) {
                const win = 0.5 * (1 - Math.cos(2*Math.PI*i/(fftSize-1)));
                seg[i] = ir[center - fftSize/2 + i] * win;
            }
        }
        
        const cOut = fft.createComplexArray();
        fft.realTransform(cOut, seg);
        
        const freqs = [], amps = [];
        for(let i=0; i<fftSize/2; i++) {
            const mag = Math.sqrt(cOut[2*i]**2 + cOut[2*i+1]**2);
            freqs.push(i * sr / fftSize);
            amps.push(20*Math.log10(mag + 1e-9));
        }
        results[h] = { freqs, amps };
    });
    
    globalData.essResults = results;
    resetChartView(f1, f2);
    drawMainChart();
    updateEssReport(results, f1, f2);
    analyzePeak();
}

// ==================== 5. 图表绘制引擎 (支持缩放/网格) ====================

// 初始化图表交互
function initChartInteraction(canvasId, viewObj, drawFn) {
    const canvas = $(canvasId);
    
    // 滚轮缩放
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const w = canvas.width;
        
        if (viewObj === chartView) {
            // 频率轴缩放 (对数逻辑较复杂，这里简化为范围缩放)
            // 简单逻辑：缩放 factor
            const factor = e.deltaY > 0 ? 1.1 : 0.9;
            const range = viewObj.freq.max - viewObj.freq.min;
            const newRange = range * factor;
            const mouseFrac = mouseX / w;
            // 保持鼠标指向的频率位置相对不变
            const fMouse = viewObj.freq.min + range * mouseFrac; 
            
            viewObj.freq.min = fMouse - newRange * mouseFrac;
            viewObj.freq.max = fMouse + newRange * (1 - mouseFrac);
            // 限制
            if(viewObj.freq.min < 1) viewObj.freq.min = 1;
        } else {
            // 波形缩放
            const factor = e.deltaY > 0 ? 0.8 : 1.25;
            viewObj.zoom *= factor;
            if(viewObj.zoom < 1) viewObj.zoom = 1;
        }
        drawFn();
    }, {passive:false});

    // 拖拽平移
    canvas.addEventListener('mousedown', e => {
        viewObj.isDragging = true;
        viewObj.lastX = e.clientX;
    });
    window.addEventListener('mouseup', () => viewObj.isDragging = false);
    window.addEventListener('mousemove', e => {
        if (!viewObj.isDragging) return;
        const dx = e.clientX - viewObj.lastX;
        viewObj.lastX = e.clientX;
        const w = canvas.width;
        
        if (viewObj === chartView) {
            const range = viewObj.freq.max - viewObj.freq.min;
            const shift = - (dx / w) * range;
            viewObj.freq.min += shift;
            viewObj.freq.max += shift;
        } else {
            // 波形平移
            viewObj.offset -= dx / viewObj.zoom; 
        }
        drawFn();
    });
    
    // 双击复位
    canvas.addEventListener('dblclick', () => {
        if (viewObj === chartView) resetChartView(globalData.fStart, globalData.fEnd);
        else { tapView.zoom = 1; tapView.offset = 0; }
        drawFn();
    });
}

function resetChartView(f1, f2) {
    chartView.freq.min = f1;
    chartView.freq.max = f2;
    chartView.db.min = -100;
    chartView.db.max = 0;
}

// 主绘制函数
function drawMainChart() {
    const canvas = $('plot');
    // 处理 Retina 屏清晰度
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.parentNode.getBoundingClientRect();
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    const ctx = canvas.getContext('2d');
    ctx.scale(dpr, dpr);
    const w = rect.width;
    const h = rect.height;

    // 背景
    ctx.fillStyle = "#061225";
    ctx.fillRect(0, 0, w, h);
    
    const fMin = chartView.freq.min;
    const fMax = chartView.freq.max;
    if (fMin >= fMax) return;

    // 绘制网格与坐标
    drawGrid(ctx, w, h, fMin, fMax, -100, 10);

    // 准备数据
    if (globalData.type === 'step') {
        const data = globalData.stepData;
        if(data.length < 2) return;
        
        ctx.beginPath();
        ctx.strokeStyle = "#3fa7ff";
        ctx.lineWidth = 2;
        let started = false;
        
        // LogX 映射
        const logMin = Math.log10(fMin);
        const logMax = Math.log10(fMax);
        const scaleX = w / (logMax - logMin);

        data.forEach(p => {
            if(p.f < fMin || p.f > fMax) return;
            const x = (Math.log10(p.f) - logMin) * scaleX;
            // Map dB (-100 to 0) to Y
            const y = h - ((p.db + 100) / 100) * h; 
            if(!started) { ctx.moveTo(x, y); started = true; }
            else ctx.lineTo(x,y);
        });
        ctx.stroke();
    } 
    else if (globalData.type === 'ess' && globalData.essResults) {
        const colors = {1:'#3fa7ff', 2:'#ffcf6b', 3:'#ff6b6b'};
        const logMin = Math.log10(fMin);
        const scaleX = w / (Math.log10(fMax) - logMin);

        // 获取要显示的谐波
        const visibleH = Array.from(document.querySelectorAll('.hToggle'))
                         .filter(c=>c.checked).map(c=>parseInt(c.value));
        
        // 自动调整 Y 范围以适应数据
        let maxDb = -100;
        visibleH.forEach(k => {
            if(globalData.essResults[k]) maxDb = Math.max(maxDb, ...globalData.essResults[k].amps);
        });
        const yTop = Math.ceil(maxDb/10)*10 + 10;
        const yBot = yTop - 90;

        visibleH.forEach(k => {
            if(!globalData.essResults[k]) return;
            const {freqs, amps} = globalData.essResults[k];
            ctx.beginPath();
            ctx.strokeStyle = colors[k] || '#fff';
            ctx.lineWidth = k===1 ? 2 : 1;
            let started = false;
            
            for(let i=0; i<freqs.length; i++) {
                const f = freqs[i];
                if(f < fMin || f > fMax) continue;
                const x = (Math.log10(f) - logMin) * scaleX;
                const y = h - ((amps[i] - yBot) / (yTop - yBot)) * h;
                if(!started) { ctx.moveTo(x,y); started = true; }
                else ctx.lineTo(x,y);
            }
            ctx.stroke();
        });
    }
}

function drawGrid(ctx, w, h, fMin, fMax, dbMin, dbMax) {
    ctx.lineWidth = 1;
    ctx.font = "10px sans-serif";
    const logMin = Math.log10(fMin);
    const logRange = Math.log10(fMax) - logMin;

    // 频率竖线
    ctx.strokeStyle = "#1f2a44";
    ctx.fillStyle = "#5c6b8f";
    ctx.textAlign = "center";
    
    // 生成 10, 20... 100, 200... 网格
    let base = Math.pow(10, Math.floor(logMin));
    while(base < fMax) {
        [1, 2, 5].forEach(mult => {
            const f = base * mult;
            if(f >= fMin && f <= fMax) {
                const x = (Math.log10(f) - logMin) / logRange * w;
                ctx.beginPath();
                ctx.moveTo(x, 0); ctx.lineTo(x, h);
                ctx.stroke();
                const txt = f >= 1000 ? (f/1000)+'k' : f;
                ctx.fillText(txt, x, h - 5);
            }
        });
        base *= 10;
    }

    // 幅度横线
    ctx.textAlign = "left";
    const range = 100; // fixed -100 to 0 mostly
    for(let db = 0; db >= -100; db -= 20) {
        const y = h - ((db + 100) / 100) * h;
        ctx.beginPath();
        ctx.moveTo(0, y); ctx.lineTo(w, y);
        ctx.stroke();
        ctx.fillText(db+"dB", 5, y - 2);
    }
}

// 敲击检测绘图
function drawTapChart() {
    const canvas = $('tapWave');
    if (!tapDataRaw) return;
    
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.parentNode.getBoundingClientRect();
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    const ctx = canvas.getContext('2d');
    ctx.scale(dpr, dpr);
    const w = rect.width;
    const h = rect.height;

    ctx.fillStyle = "#061225";
    ctx.fillRect(0,0,w,h);
    
    // 中线
    ctx.strokeStyle = "#1f2a44";
    ctx.beginPath(); ctx.moveTo(0, h/2); ctx.lineTo(w, h/2); ctx.stroke();

    ctx.strokeStyle = "#5fc0ff";
    ctx.lineWidth = 1;
    ctx.beginPath();
    
    const len = tapDataRaw.length;
    // 每一个像素点代表的数据量
    const step = Math.max(1, Math.floor(len / w / tapView.zoom));
    const startIdx = Math.floor(tapView.offset);
    
    let hasMoved = false;
    for(let x = 0; x < w; x++) {
        const idx = startIdx + Math.floor(x * step);
        if (idx >= 0 && idx < len) {
            const v = tapDataRaw[idx];
            const y = h/2 + v * (h/2) * 0.9; // 0.9 margin
            if(!hasMoved) { ctx.moveTo(x, y); hasMoved=true; }
            else ctx.lineTo(x, y);
        }
    }
    ctx.stroke();
}

// ==================== 6. 数据分析与导出 ====================

function analyzePeak() {
    let peakF = 0, peakA = -999;
    
    if (globalData.type === 'step') {
        globalData.stepData.forEach(p => {
            if(p.db > peakA) { peakA = p.db; peakF = p.f; }
        });
        $('peakAmp').textContent = peakA.toFixed(1) + " dB";
    } else if (globalData.type === 'ess' && globalData.essResults && globalData.essResults[1]) {
        const h1 = globalData.essResults[1];
        for(let i=0; i<h1.amps.length; i++) {
            if(h1.freqs[i] >= globalData.fStart && h1.freqs[i] <= globalData.fEnd) {
                if(h1.amps[i] > peakA) { peakA = h1.amps[i]; peakF = h1.freqs[i]; }
            }
        }
        $('peakAmp').textContent = peakA.toFixed(1) + " dB";
    }
    
    if(peakF > 0) $('peakFreq').textContent = peakF.toFixed(1);
    else $('peakFreq').textContent = "—";
}

function updateEssReport(res, f1, f2) {
    let txt = `ESS 扫频分析 (范围 ${f1}-${f2} Hz)\n--------------------------------\n`;
    if(res[1]) {
        let pF=0, pA=-999;
        const r = res[1];
        for(let i=0; i<r.amps.length; i++) {
            if(r.freqs[i]>=f1 && r.freqs[i]<=f2 && r.amps[i]>pA) { pA=r.amps[i]; pF=r.freqs[i]; }
        }
        txt += `基频响应 (H1) 峰值: ${pF.toFixed(1)} Hz @ ${pA.toFixed(1)} dB\n`;
    }
    
    [2,3].forEach(k => {
        if(res[k]) {
            let maxD = -999;
            res[k].amps.forEach(a => maxD = Math.max(maxD, a));
            txt += `H${k} 谐波最大幅度: ${maxD.toFixed(1)} dB\n`;
        }
    });
    $('essReportText').textContent = txt;
}

// 敲击检测
$('tapDetectBtn').addEventListener('click', async function() {
    const btn = this;
    btn.disabled = true;
    btn.textContent = "录音中...";
    const ctx = getAudioCtx();
    await ctx.resume();

    try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const rec = new MediaRecorder(stream);
        const chunks = [];
        rec.ondataavailable = e => chunks.push(e.data);
        rec.start();
        await sleep(2000);
        rec.stop();
        await new Promise(r => rec.onstop = r);
        stream.getTracks().forEach(t => t.stop());

        const blob = new Blob(chunks, { type: 'audio/webm' });
        const buf = await blob.arrayBuffer();
        const audioB = await ctx.decodeAudioData(buf);
        let data = audioB.getChannelData(0);

        // 高通滤波
        if ($('enableHPF').checked) {
            const offline = new OfflineAudioContext(1, data.length, audioB.sampleRate);
            const b = offline.createBuffer(1, data.length, audioB.sampleRate);
            b.copyToChannel(data, 0);
            const s = offline.createBufferSource();
            s.buffer = b;
            const f = offline.createBiquadFilter();
            f.type = 'highpass';
            f.frequency.value = 50;
            s.connect(f);
            f.connect(offline.destination);
            s.start();
            const out = await offline.startRendering();
            data = out.getChannelData(0);
        }

        tapDataRaw = data;
        tapView.zoom = 1; tapView.offset = 0; // reset
        drawTapChart();
        
        // 基频估算 (自相关)
        const pitch = detectPitch(data, audioB.sampleRate);
        $('tapFreq').textContent = pitch ? pitch.toFixed(1) : "—";
        
        // 下载
        const wav = audioBufferToWav(data, audioB.sampleRate);
        const url = URL.createObjectURL(wav);
        const dl = $('downloadTap');
        dl.href = url;
        dl.download = `impulse_${new Date().getTime()}.wav`;
        dl.style.display = 'inline-block';

    } catch(e) {
        alert("录音失败: " + e.message);
    } finally {
        btn.disabled = false;
        btn.textContent = "开始敲击录音 (2s)";
    }
});

function detectPitch(buf, sr) {
    // 简单自相关，寻找最大峰
    const n = 1024;
    let maxRms=0, pos=0;
    // 找能量最大的片段
    for(let i=0; i<buf.length-n; i+=512) {
        let s=0; for(let j=0; j<n; j++) s+=buf[i+j]*buf[i+j];
        if(s>maxRms){maxRms=s; pos=i;}
    }
    const chunk = buf.slice(pos, pos+n);
    
    let bestR=0, bestK=-1;
    for(let k=20; k<n/2; k++) { // ~2kHz down to low freq
        let sum=0;
        for(let i=0; i<n-k; i++) sum += chunk[i]*chunk[i+k];
        if(sum > bestR) { bestR=sum; bestK=k; }
    }
    return bestK > 0 ? sr/bestK : null;
}

// 导出 CSV
$('exportCSV').onclick = () => {
    let csv = "";
    if (globalData.type === 'step') {
        csv = "Freq(Hz),Amp(dB)\n" + globalData.stepData.map(p=>`${p.f.toFixed(2)},${p.db.toFixed(2)}`).join("\n");
        downloadFile(csv, 'step_sweep.csv');
    } else if (globalData.type === 'ess' && globalData.essResults) {
        const h1 = globalData.essResults[1];
        if(!h1) return;
        csv = "Freq(Hz),H1(dB),H2(dB),H3(dB)\n";
        for(let i=0; i<h1.freqs.length; i++) {
            const f = h1.freqs[i];
            if(f < globalData.fStart) continue;
            if(f > globalData.fEnd) break;
            let row = `${f.toFixed(2)},${h1.amps[i].toFixed(2)}`;
            [2,3].forEach(k => row += `,${globalData.essResults[k] ? globalData.essResults[k].amps[i].toFixed(2) : ''}`);
            csv += row + "\n";
        }
        downloadFile(csv, 'ess_sweep.csv');
    } else {
        alert("暂无数据");
    }
};

function downloadFile(content, name) {
    const b = new Blob([content], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(b); a.download = name;
    document.body.appendChild(a); a.click(); document.body.removeChild(a);
}

// WAV Header Helper
function audioBufferToWav(samples, sr) {
    const buf = new ArrayBuffer(44 + samples.length * 2);
    const v = new DataView(buf);
    const writeS = (o, s) => { for(let i=0;i<s.length;i++) v.setUint8(o+i, s.charCodeAt(i)); };
    writeS(0,'RIFF'); v.setUint32(4, 36+samples.length*2, true); writeS(8,'WAVE');
    writeS(12,'fmt '); v.setUint32(16,16,true); v.setUint16(20,1,true); v.setUint16(22,1,true);
    v.setUint32(24,sr,true); v.setUint32(28,sr*2,true); v.setUint16(32,2,true); v.setUint16(34,16,true);
    writeS(36,'data'); v.setUint32(40,samples.length*2,true);
    for(let i=0; i<samples.length; i++) {
        let s = Math.max(-1, Math.min(1, samples[i]));
        v.setInt16(44+i*2, s<0 ? s*0x8000 : s *0x7FFF, true);
    }
    return new Blob([v], {type:'audio/wav'});
}

// 初始化
initChartInteraction('plot', chartView, drawMainChart);
initChartInteraction('tapWave', tapView, drawTapChart);
document.querySelectorAll('.hToggle').forEach(el => el.addEventListener('change', drawMainChart));
window.addEventListener('resize', () => { drawMainChart(); drawTapChart(); });
</script>
</body>
</html>
