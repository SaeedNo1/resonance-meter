<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>resonance-meter</title>
<link rel="icon" type="image/png" sizes="48x48" href="logo-42px.png">
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:#0f1724;color:#e6eef8;margin:0;padding:16px}
  .wrap{max-width:900px;margin:0 auto}
  h1{font-size:20px;margin:6px 0 12px}
  .card{background:#0b1220;border:1px solid #1f2a44;border-radius:12px;padding:12px;margin-bottom:12px}
  label{font-size:13px;color:#9fb0d6;display:block;margin-top:8px}
  input,select,button{font-size:15px;padding:8px;border-radius:8px;border:1px solid #26364f;background:#081024;color:#e6eef8;width:100%}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .controls{display:flex;gap:8px;margin-top:8px}
  button.primary{background:#3fa7ff;border:none;color:#032033}
  canvas{width:100%;height:240px;background:#061225;border-radius:8px;border:1px solid #22314a}
  .pill{display:inline-block;padding:8px 12px;border-radius:999px;background:#07162b;color:#bfe0ff;margin-right:8px}
  .small{font-size:13px;color:#95b7dc}
  .hint{font-size:12px;color:#95b7dc;margin-top:8px}
  a{color:#82c1ff}
</style>
</head>
<body>
<div class="wrap">
  <h1>å›ºæœ‰é¢‘ç‡æ‰«æµ‹</h1>

  <div class="card">
    <div class="row">
      <div>
        <label>èµ·å§‹é¢‘ç‡ (Hz)</label>
        <input id="fStart" type="number" value="50" step="0.1" min="1" />
      </div>
      <div>
        <label>ç»ˆæ­¢é¢‘ç‡ (Hz)</label>
        <input id="fEnd" type="number" value="2000" step="0.1" min="1" />
      </div>
    </div>

    <div class="row">
      <div>
        <label>æ­¥æ•°ï¼ˆstepsï¼Œä¸ä½œç”¨ESSï¼‰</label>
        <input id="steps" type="number" value="80" min="2" />
      </div>
      <div>
        <label>æ¯æ­¥æ—¶é•¿ (msï¼Œä¸ä½œç”¨ESS)</label>
        <input id="dur" type="number" value="120" min="20" />
      </div>
      <div>
        <label>æ—¶é•¿ (s)</label>
        <input id="essDur" type="number" value="10" step="1" min="1" />
      </div>
    </div>
    <label>æ³¢å½¢</label>
    <select id="wave">
      <option value="sine">æ­£å¼¦</option>
      <option value="triangle">ä¸‰è§’</option>
      <option value="sawtooth">é”¯é½¿</option>
      <option value="square">æ–¹æ³¢</option>
    </select>
    <div id="harmonicSelector" style="margin-top:8px; color:#fff;">
    <label><input type="checkbox" class="hToggle" value="1" checked> H1</label>
    <label><input type="checkbox" class="hToggle" value="2" checked> H2</label>
    <label><input type="checkbox" class="hToggle" value="3" checked> H3</label>
    <label><input type="checkbox" class="hToggle" value="4" checked> H4</label>
    </div>
    <label>éŸ³é‡ï¼ˆæ’­æ”¾å¢ç›Šï¼Œ0-1ï¼Œè¿‡å¤§è¯·è°¨æ…ï¼‰</label>
    <input id="gain" type="range" min="0" max="1" step="0.001" value="0.8" />

    <div class="controls">
      <button id="startSweep" class="primary">å¼€å§‹æ‰«é¢‘</button>
      <button id="stopSweep">åœæ­¢</button>
      <button id="baselineBtn">é‡‡é›†èƒŒæ™¯</button>
      <button id="exportCSV">å¯¼å‡º CSV</button>
      <button id="essBtn">ESS æ‰«é¢‘æµ‹è¯•</button>
      <button onclick="location.href='Frequency.html'">å‡†å¤‡å…±æŒ¯</button>
    </div>

    <div id="hud" style="margin-top:10px; color:#0f0; font-family:monospace;">
      å½“å‰é¢‘ç‡: <span id="hudFreq">â€”</span> Hzã€€
      è¿›åº¦: <span id="hudProg">0</span>%
    </div>

    <div style="margin-top:10px">
      <span class="pill">æ£€æµ‹å³°å€¼ï¼š<span id="peakFreq">â€”</span> Hz</span>
      <span class="pill">å³°å€¼å¹…åº¦ï¼š<span id="peakAmp">â€”</span></span>
    </div>
    <div class="hint">è¯´æ˜ï¼šæ­¤å·¥å…·åœ¨æ‰‹æœºä¸Šä¾èµ–æ‰¬å£°å™¨æŠŠæ¿€åŠ±å£°æ’­ç»™è¢«æµ‹ä½“ï¼Œè¢«æµ‹ä½“æŒ¯åŠ¨å†ç”±éº¦å…‹é£æ‹¾å–ã€‚ä¸ºé¿å…ç›´è¾¾å£°è¦†ç›–ç»“æ„å…±æŒ¯ä¿¡å·ï¼Œè¯·æŠŠéº¦å…‹é£å°½é‡è´´è¿‘è¢«æµ‹ä½“æŒ¯åŠ¨ç‚¹å¹¶æŒ‰åˆé€‚ä½ç½®æ”¾ç½®æ‰¬å£°å™¨ï¼ˆæˆ–ä½¿ç”¨è€¦åˆæ–¹å¼ï¼‰ã€‚è¯·æ³¨æ„å¬åŠ›å®‰å…¨ï¼Œé¿å…å¤§éŸ³é‡é•¿æ—¶é—´æ’­æ”¾ã€‚å¦‚æœæ²¡æœ‰å®éªŒå®¤ç¯å¢ƒå»ºè®®å…ˆé‡‡é›†èƒŒæ™¯ï¼Œæœ€å¥½ä½¿ç”¨</div>
    <a href="introduce/ESS.html">æŒ‡æ•°æ­£å¼¦æ‰«(ESS)</a>
  </div>
  <div id="essPeak">å³°å€¼: â€”</div>
  <div class="card">
    <canvas id="plot" width="800" height="320"></canvas>
  </div>
</div>
  <div id="essReport" style="margin-top:10px; padding:10px; background:#111; color:#0f0; font-family:monospace; border-radius:6px;">
  <b>åˆ†ææŠ¥å‘Šï¼š</b>
  <pre id="essReportText">ï¼ˆç­‰å¾… ESS æ‰«æç»“æœ...ï¼‰</pre>
</div>
  
<div style="padding:8px; margin-top:8px;">
  <button id="tapDetectBtn">æ•²å‡»æ£€æµ‹ï¼ˆå½•éŸ³ 2sï¼‰</button>
  <label style="margin-left:10px;">
  <input type="checkbox" id="enableHPF"> å¯ç”¨é«˜é€šæ»¤æ³¢
</label>
<input type="number" id="hpfValue" value="50" min="0" max="500" style="width:70px;"> Hz
  <button id="downloadTap" style="display:none">ä¸‹è½½å½•éŸ³ (WAV)</button>
  <div style="margin-top:8px;">
    <span class="pill">æ•²å‡»åŸºé¢‘: <span id="tapFreq">â€”</span> Hz</span>
  </div>
  <canvas id="tapWave" width="600" height="120" style="margin-top:8px;border-radius:6px;background:#061225"></canvas>
</div>
  <script src="JS/fft.js"></script>
<script>
let audioCtx = null;
let baselineSpectrum = null;
(async function(){
  const $ = id => document.getElementById(id);
  let micStream = null;
  let micSrc = null;
  let analyser = null;
  let running = false;
  let dataPoints = []; // {f, amp}
  let osc = null;
  let gainNode = null;
  let nyquist = 22050;
  const g = plot.getContext('2d');
  function ensureAudio(){
    if (!audioCtx){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)({latencyHint:'interactive'});
      nyquist = audioCtx.sampleRate/2;
    }
    return audioCtx;
  }

  function clearPlot(){
    g.fillStyle = '#061225';
    g.fillRect(0,0,plot.width,plot.height);
    // axes
    g.strokeStyle = '#17334f';
    g.lineWidth = 1;
    // x baseline
    g.beginPath(); g.moveTo(40, plot.height-30); g.lineTo(plot.width-10, plot.height-30); g.stroke();
    // y baseline
    g.beginPath(); g.moveTo(40,10); g.lineTo(40, plot.height-30); g.stroke();
    // labels
    g.fillStyle = '#7fb7e8'; g.font = '12px system-ui';
    g.fillText('é¢‘ç‡ (Hz)', plot.width/2-20, plot.height-6);
    g.fillText('å“åº” (ç›¸å¯¹å¹…åº¦)', 6, 18);
  }
  if (baselineSpectrum && spectrum && spectrum.length) {
  spectrum = spectrum.map((v, i) => Math.max(0, v - (baselineSpectrum[i] || 0)));
  }
  function drawCurve(points){
    clearPlot();
    if (!points || points.length===0) return;
    // map frequency log scale for better visibility if wide range
    const fmin = Math.min(...points.map(p=>p.f));
    const fmax = Math.max(...points.map(p=>p.f));
    const amin = Math.min(...points.map(p=>p.amp));
    const amax = Math.max(...points.map(p=>p.amp));
    const w = plot.width, h = plot.height;
    const left = 40, right = w-10, top = 10, bottom = h-30;
    // grid ticks
    g.strokeStyle = '#10263a';
    g.lineWidth = 1;
    g.font = '11px system-ui';
    g.fillStyle = '#9ecff7';
    // draw x ticks (log spaced)
    const tickFs = [fmin, fmax];
    for (let t of [fmin, fmax]){
      g.fillText(Math.round(t)+'Hz', t===fmin? left : right-40, bottom+18);
    }
    // path
    g.lineWidth = 2;
    g.strokeStyle = '#58b7ff';
    g.beginPath();
    for (let i=0;i<points.length;i++){
      const p = points[i];
      const fx = (Math.log(p.f) - Math.log(fmin)) / (Math.log(fmax) - Math.log(fmin || 1e-6));
      const x = left + fx*(right-left);
      const ay = (p.amp - amin) / (amax - amin || 1e-6);
      const y = bottom - ay*(bottom-top);
      if (i===0) g.moveTo(x,y); else g.lineTo(x,y);
    }
    g.stroke();
    // mark peak
    const peak = points.reduce((a,b)=> b.amp>a.amp?b:a, points[0]);
    const pf = peak.f, pa = peak.amp;
    const fx = (Math.log(pf) - Math.log(fmin)) / (Math.log(fmax) - Math.log(fmin || 1e-6));
    const x = left + fx*(right-left);
    const ay = (pa - amin) / (amax - amin || 1e-6);
    const y = bottom - ay*(bottom-top);
    g.fillStyle = '#ffcf6b';
    g.beginPath(); g.arc(x,y,5,0,2*Math.PI); g.fill();
    g.fillStyle = '#ffd'; g.font = '13px system-ui';
    g.fillText('å³°: '+pf.toFixed(2)+' Hz', x+8, y-8);
  }

  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

  async function startMic(){
    ensureAudio();
    if (micStream) return;
    micStream = await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:false,noiseSuppression:false,autoGainControl:false}});
    micSrc = audioCtx.createMediaStreamSource(micStream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    analyser.smoothingTimeConstant = 0.0;
    micSrc.connect(analyser);
  }

  function stopMic(){
    if (micStream){
      micStream.getTracks().forEach(t=>t.stop());
      micStream = null;
      micSrc && micSrc.disconnect();
      analyser && analyser.disconnect();
      analyser = null;
    }
  }

  function getRMSFromTimeDomain(buf){
    let sum=0;
    for (let i=0;i<buf.length;i++){ const v=buf[i]; sum+=v*v; }
    return Math.sqrt(sum/buf.length);
  }

  async function runSweep(){
    if (running) return;
    running = true;
    dataPoints = [];
    $('peakFreq').textContent = 'â€”';
    $('peakAmp').textContent = 'â€”';
    clearPlot();

    const start = parseFloat($('fStart').value) || 1;
    const end = parseFloat($('fEnd').value) || 1000;
    let steps = parseInt($('steps').value) || 80;
    const dur = Math.max(20, parseFloat($('dur').value) || 100); // ms per step
    const wave = $('wave').value;
    const gainVal = parseFloat($('gain').value) || 0.6;

    // clamp to Nyquist/2
    ensureAudio();
    if (start <= 0) { alert('èµ·å§‹é¢‘ç‡å¿…é¡» > 0'); running=false; return; }
    const maxPlayable = Math.max(1, audioCtx.sampleRate/2 - 1);
    if (end > maxPlayable){
      if (!confirm(`ä½ è®¾ç½®çš„ç»ˆæ­¢é¢‘ç‡ (${end} Hz) è¶…è¿‡è®¾å¤‡å¯æ’­æ”¾ä¸Šé™çº¦ ${Math.floor(maxPlayable)} Hzï¼Œæ˜¯å¦ç»§ç»­å¹¶è‡ªåŠ¨å¤¹åˆ°ä¸Šé™ï¼Ÿ`)) {
        running=false; return;
      }
    }
    const fEndClamped = Math.min(end, maxPlayable);
    // ensure steps not too large
    if (steps > 800) steps = 800;

    // prepare microphone (get permission)
    try {
      await startMic();
    } catch(e){
      alert('æ— æ³•æ‰“å¼€éº¦å…‹é£ï¼š'+e.message);
      running=false; return;
    }

    // prepare playback oscillator + gain
    if (!gainNode){
      gainNode = audioCtx.createGain();
      gainNode.gain.value = gainVal;
      gainNode.connect(audioCtx.destination);
    }
    gainNode.gain.setValueAtTime(gainVal, audioCtx.currentTime);

    // We'll play discrete tones using oscillator, stopping/starting each step
    const freqs = [];
    for (let i=0;i<steps;i++){
      const t = i/(steps-1);
      // linear in frequency (you can change to logarithmic if desired)
      const f = start * Math.pow(fEndClamped/start, t); // log spaced: better for resonance detection
      freqs.push(f);
    }

    const timeDomain = new Float32Array(analyser.fftSize);

    for (let i=0;i<freqs.length;i++){
      if (!running) break;
      const f = freqs[i];
      // create oscillator for this step
      const o = audioCtx.createOscillator();
      o.type = wave;
      o.frequency.setValueAtTime(f, audioCtx.currentTime);
      o.connect(gainNode);
      o.start();
      // let it stabilize for half step, measure during remainder
      const measureMs = Math.max(10, Math.floor(dur*0.8));
      const warmMs = Math.max(0, Math.floor(dur - measureMs));
      await sleep(warmMs);

      // measure RMS across measureMs duration by sampling multiple frames
      const sampleStart = performance.now();
      let samples = [];
      while (performance.now() - sampleStart < measureMs){
        analyser.getFloatTimeDomainData(timeDomain);
        const rms = getRMSFromTimeDomain(timeDomain);
        samples.push(rms);
        // small await to avoid blocking (frame aligned)
        await sleep(8);
      }
      const meanRms = samples.reduce((a,b)=>a+b,0)/Math.max(1,samples.length);
      // record
      dataPoints.push({f, amp: meanRms});
      // update plot incrementally
      drawCurve(dataPoints);
      // cleanup oscillator
      try { o.stop(); o.disconnect(); } catch(e){}
      // small gap between steps
      await sleep( Math.max(2, Math.floor(dur*0.02)) );
    }

    // finished
    running = false;
    // compute peak
    if (dataPoints.length>0){
      const peak = dataPoints.reduce((a,b)=> b.amp>a.amp?b:a, dataPoints[0]);
      $('peakFreq').textContent = peak.f.toFixed(3);
      $('peakAmp').textContent = peak.amp.toExponential(2);
      // optionally refine around peak: do narrow high-resolution sweep near peak (not implemented automatically)
    }
    stopMic();
  }

  // UI bindings
  $('startSweep').addEventListener('click', async ()=>{
    // user gesture: resume audio context
    ensureAudio();
    if (audioCtx.state === 'suspended') await audioCtx.resume();
    runSweep();
  });

  $('stopSweep').addEventListener('click', ()=>{
    running = false;
    // stop any playing oscillator immediately
    try { if (osc) { osc.stop(); osc.disconnect(); osc=null; } } catch(e){}
    // also try to set gain 0
    try { if (gainNode) gainNode.gain.setValueAtTime(0, audioCtx.currentTime); } catch(e){}
    stopMic();
  });

  $('exportCSV').addEventListener('click', ()=>{
    if (!dataPoints || dataPoints.length===0){ alert('æš‚æ— æ•°æ®ï¼Œå…ˆæ‰§è¡Œä¸€æ¬¡æ‰«é¢‘ã€‚'); return; }
    let csv = 'freq_hz,amp_rms\n' + dataPoints.map(p => `${p.f.toFixed(6)},${p.amp}`).join('\n');
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'resonance_sweep.csv'; document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  });

  // initial plot
  clearPlot();

  // cleanup on page hide
  window.addEventListener('pagehide', ()=>{
    running=false;
    try { stopMic(); if (audioCtx) audioCtx.close(); } catch(e){}
  });
document.getElementById("baselineBtn").onclick = async () => {
  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  const src = audioCtx.createMediaStreamSource(stream);
if (document.getElementById("enableHPF").checked) {
  const highpass = audioCtx.createBiquadFilter();
  highpass.type = "highpass";
  highpass.frequency.value = parseFloat(document.getElementById("hpfValue").value) || 50;
  src.connect(highpass);
  src = highpass;
}
analyser = audioCtx.createAnalyser();
src.connect(analyser);
  const baselineAnalyser = audioCtx.createAnalyser();
  baselineAnalyser.fftSize = 2048;
  src.connect(baselineAnalyser);

  const bufferLength = baselineAnalyser.frequencyBinCount;
  const dataArray = new Uint8Array(bufferLength);

  setTimeout(() => {
    baselineAnalyser.getByteFrequencyData(dataArray);
    baselineSpectrum = Array.from(dataArray);
    alert("èƒŒæ™¯é‡‡é›†å®Œæˆï¼");
  }, 2000); // é‡‡é›†2ç§’
};
})();
  // =============== ESSï¼ˆæŒ‡æ•°æ­£å¼¦æ‰«ï¼‰åŠŸèƒ½ ===============

// ç”Ÿæˆ ESS æ³¢å½¢
function generateESS(f1, f2, duration, sampleRate) {
  const N = Math.floor(duration * sampleRate);
  const sweep = new Float32Array(N);

  const L = Math.log(f2 / f1);
  for (let n = 0; n < N; n++) {
    const t = n / sampleRate;
    const angle = 2 * Math.PI * f1 * (duration / L) * (Math.exp(t * L / duration) - 1);
    sweep[n] = Math.sin(angle);
  }
  return sweep;
}
  // ç”Ÿæˆ ESS åŠå¯¹åº”çš„ inverse filter
function generateESSandInverse(f1, f2, duration, sampleRate) {
  const N = Math.floor(duration * sampleRate);
  const sweep = new Float32Array(N);
  const L = Math.log(f2 / f1);

  for (let n = 0; n < N; n++) {
    const t = n / sampleRate;
    const angle = 2 * Math.PI * f1 * (duration / L) * (Math.exp(t * L / duration) - 1);
    sweep[n] = Math.sin(angle);
  }

  // inverse filterï¼ˆç”¨äºåå·ç§¯ï¼‰
  const inv = new Float32Array(N);
  for (let n = 0; n < N; n++) {
    const t = (N - 1 - n) / sampleRate; // åå‘æ—¶é—´
    const angle = 2 * Math.PI * f1 * (duration / L) * (Math.exp(t * L / duration) - 1);
    // åŠ ä¸Šè¡¥å¿ exp(-t*L/duration)
    inv[n] = Math.sin(angle) * Math.exp(-t * L / duration);
  }

  return { sweep, inv };
}

// æ’­æ”¾ ESS å¹¶å½•éŸ³
async function playAndRecordESS() {
  const f1 = parseFloat(document.getElementById("fStart").value) || 20;
  const f2 = parseFloat(document.getElementById("fEnd").value) || 20000;
  const dur = parseFloat(document.getElementById("essDur").value) || 10;
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const sampleRate = audioCtx.sampleRate;
  
 const { sweep:ess, inv } = generateESSandInverse(f1, f2, dur, sampleRate);

  // å‡†å¤‡ buffer æ’­æ”¾
  const buffer = audioCtx.createBuffer(1, ess.length, sampleRate);
  buffer.copyToChannel(ess, 0, 0);
  const src = audioCtx.createBufferSource();
  src.buffer = buffer;

  // æ‰“å¼€éº¦å…‹é£
  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  const mediaRecorder = new MediaRecorder(stream);

  let chunks = [];
  mediaRecorder.ondataavailable = e => chunks.push(e.data);

  mediaRecorder.start();

  // æ’­æ”¾
  src.connect(audioCtx.destination);
  src.start();
  // === HUD å®æ—¶æ›´æ–° ===
const startTime = audioCtx.currentTime;
const totalDuration = dur;
const fStart = f1, fEnd = f2;

function updateHUD() {
  const t = audioCtx.currentTime - startTime;
  if (t >= totalDuration) {
    document.getElementById("hudProg").textContent = "100";
    document.getElementById("hudFreq").textContent = fEnd.toFixed(1);
    return;
  }
  const instFreq = fStart * Math.pow(fEnd / fStart, t / totalDuration); // ESS é¢‘ç‡ç¬æ—¶å€¼
  document.getElementById("hudFreq").textContent = instFreq.toFixed(1);
  document.getElementById("hudProg").textContent = ((t / totalDuration) * 100).toFixed(0);
  requestAnimationFrame(updateHUD);
}
updateHUD();
  // æ’­æ”¾ç»“æŸæ—¶åœæ­¢å½•éŸ³
  src.onended = () => {
    mediaRecorder.stop();
  };
  // ===== FFT é¢‘åŸŸå·ç§¯å‡½æ•° =====
function fftConvolve(a, b) {
  const N = a.length + b.length - 1;
  const fftSize = 1 << Math.ceil(Math.log2(N));
  const fft = new FFT(fftSize);

  // è½¬ä¸ºå¤æ•°ç»„
  const A = fft.createComplexArray();
  const B = fft.createComplexArray();
  const C = fft.createComplexArray();
  const out = new Float32Array(fftSize);

  fft.realTransform(A, a);
  fft.realTransform(B, b);

  // é¢‘åŸŸä¹˜æ³•ï¼šC = A * B
  for (let i = 0; i < fftSize; i += 2) {
    const ar = A[i], ai = A[i + 1];
    const br = B[i], bi = B[i + 1];
    C[i] = ar * br - ai * bi;
    C[i + 1] = ar * bi + ai * br;
  }

  fft.inverseTransform(C, C);

  // å–å®éƒ¨
  for (let i = 0; i < out.length; i++) {
    out[i] = C[i] / fftSize;
  }

  return out;
}
  mediaRecorder.onstop = async () => {
  console.log("ESS onstop triggered");

  // ========== åŸºç¡€å‚æ•° ==========
  const sr = (typeof recordedBuffer !== 'undefined' && recordedBuffer?.sampleRate) ? recordedBuffer.sampleRate : 48000;
  const fftSizeIR = 16384;
  const harmonics = [1, 2, 3, 4]; // 1ä¸ºFundamentalï¼Œ2ã€3ã€4æ¬¡è°æ³¢

  // ========== 1. åŸºç¡€åå·ç§¯å¾—åˆ° ir ==========
  console.log("å¼€å§‹åå·ç§¯...");
  const ir = fftConvolve(recorded, inv, fft); // ä½ å·²æœ‰çš„å‡½æ•°

  // ========== 2. ä¸»å“åº”(çº¿æ€§éƒ¨åˆ†)å¯¹é½ ==========
  const peakIndex = ir.indexOf(Math.max(...ir.map(v => Math.abs(v))));
  const irAligned = ir.slice(peakIndex, peakIndex + fftSizeIR);

  // ========== 3. é¢„å®šä¹‰å­˜å‚¨å®¹å™¨ ==========
  const harmonicIRs = {}; // æ¯ä¸ªè°æ³¢çš„IR
  const harmonicFRFs = {}; // æ¯ä¸ªè°æ³¢çš„é¢‘å“

  // ========== 4. éå†è°æ³¢æå–å“åº”ï¼ˆåç»­æˆ‘ä»¬é€æ­¥å®ç°ï¼‰ ==========
  for (const h of harmonics) {
    console.log(`æå–ç¬¬ ${h} æ¬¡è°æ³¢...`);
    // TODO: åœ¨è¿™é‡Œå¯¹ irAligned è¿›è¡Œåˆ‡çª—ã€æå–å¯¹åº”è°æ³¢çš„æ—¶åŸŸå“åº”
    // æç¤º: ä½¿ç”¨ ESS ç†è®ºæ—¶é—´åç§»å…¬å¼ t_h = (Math.log(h) / Math.log(f2 / f1)) * T
     // === Step 1: è®¡ç®—è¯¥è°æ³¢åœ¨ IR ä¸­çš„æ—¶é—´åç§»ä½ç½® ===
    const t_h = (Math.log(h) / Math.log(f2 / f1)) * T; // ESS ç†è®ºåç§»ï¼ˆç§’ï¼‰
    const start = Math.floor(t_h * sr);
    const winSize = Math.floor(0.02 * sr); // å–20msçª—å£ï¼Œå¯è°ƒ
    const end = Math.min(start + winSize, irAligned.length);

    // === Step 2: æå–å¹¶åŠ çª—ï¼ˆHannçª—ï¼‰ ===
    const irH = new Float32Array(winSize);
    for (let i = 0; i < winSize; i++) {
      const idx = start + i;
      if (idx < irAligned.length) {
        const w = 0.5 * (1 - Math.cos(2 * Math.PI * i / (winSize - 1)));
        irH[i] = irAligned[idx] * w;
    }
  }
    harmonicIRs[h] = irH;

    // åš FFT å¾—åˆ°é¢‘å“
    const out = fft.createComplexArray();
    const buf = new Float32Array(fftSizeIR);
    buf.set(irH.slice(0, fftSizeIR));
    fft.realTransform(out, buf);
    fft.completeSpectrum(out);

    const frf = new Float32Array(fftSizeIR / 2);
    for (let i = 0; i < fftSizeIR / 2; i++) {
      const re = out[2 * i], im = out[2 * i + 1];
      frf[i] = 20 * Math.log10(Math.sqrt(re * re + im * im) + 1e-12);
    }
    harmonicFRFs[h] = frf;
  }

  // ========== 5. ç»˜å›¾ ==========
  const canvas = document.getElementById("plot");
  const ctx = canvas.getContext("2d");
// æ‰¾åˆ°æ‰€æœ‰è°æ³¢çš„æ•´ä½“å¹…åº¦èŒƒå›´
let globalMin = Infinity, globalMax = -Infinity;
for (const h of harmonics) {
  const arr = harmonicFRFs[h];
  const localMin = Math.min(...arr);
  const localMax = Math.max(...arr);
  if (localMin < globalMin) globalMin = localMin;
  if (localMax > globalMax) globalMax = localMax;
}

// è‡ªåŠ¨å½’ä¸€åŒ–èŒƒå›´ï¼ˆdBFSï¼‰
const minVal = globalMin;
const maxVal = globalMax;
const dbRange = maxVal - minVal;

// ç»˜åˆ¶èƒŒæ™¯ä¸å‚è€ƒçº¿
ctx.fillStyle = "#000";
ctx.fillRect(0, 0, canvas.width, canvas.height);

ctx.strokeStyle = "#333";
ctx.lineWidth = 1;
ctx.font = "10px monospace";
ctx.fillStyle = "#888";
for (let db = Math.ceil(minVal / 10) * 10; db <= maxVal; db += 10) {
  const y = canvas.height - ((db - minVal) / dbRange) * canvas.height;
  ctx.beginPath();
  ctx.moveTo(0, y);
  ctx.lineTo(canvas.width, y);
  ctx.stroke();
  ctx.fillText(`${db} dBFS`, 5, y - 2);
}
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  const colors = ["#007bff", "#ff4d4d", "#ff9933", "#00cc66"];
  // ========== è°æ³¢é€‰æ‹©å™¨ ==========
  const selectedHarmonics = Array.from(document.querySelectorAll(".hToggle"))
    .filter(cb => cb.checked)
    .map(cb => parseInt(cb.value));
  selectedHarmonics.forEach((h, idx) => {
    const frf = harmonicFRFs[h];
    ctx.beginPath();
    ctx.strokeStyle = colors[idx % colors.length];
    for (let i = 0; i < frf.length; i++) {
      const f = i * sr / fftSizeIR;
      if (f > 20000) break;
      const x = (f / 20000) * canvas.width;
      const norm = (frf[i] - minVal) / (maxVal - minVal + 1e-12);
      const y = canvas.height - norm * canvas.height;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.fillText(`${h}x`, 10, 20 + idx * 15);
  });
    // ç›‘å¬å¤é€‰æ¡†çŠ¶æ€å˜åŒ–é‡æ–°ç»˜å›¾
  document.querySelectorAll(".hToggle").forEach(cb => {
    cb.addEventListener("change", () => {
      mediaRecorder.onstop(); // é‡æ–°è§¦å‘ç»˜å›¾ï¼ˆä¸é‡æ–°å½•éŸ³ï¼‰
    });
  });
    // ========== 5.6 é¼ æ ‡æ‚¬åœäº¤äº’ ==========
let hoverLine = null;
const hoverInfo = document.createElement("div");
hoverInfo.style.position = "absolute";
hoverInfo.style.background = "rgba(0,0,0,0.7)";
hoverInfo.style.color = "#0f0";
hoverInfo.style.font = "12px monospace";
hoverInfo.style.padding = "2px 6px";
hoverInfo.style.borderRadius = "4px";
hoverInfo.style.display = "none";
document.body.appendChild(hoverInfo);

canvas.addEventListener("mousemove", e => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const freq = (x / canvas.width) * (sr / 2);
  const i = Math.floor((freq / (sr / 2)) * (fftSizeIR / 2));

  if (i < 0 || i >= fftSizeIR / 2) {
    hoverInfo.style.display = "none";
    return;
  }

  // è·å–ä¸»è°æ³¢å¹…åº¦
  const mainFRF = harmonicFRFs[1];
  const amp = mainFRF[i].toFixed(2);

  // ç»˜åˆ¶ç«–çº¿
  ctx.save();
  ctx.beginPath();
  ctx.strokeStyle = "#0f0";
  ctx.moveTo(x, 0);
  ctx.lineTo(x, canvas.height);
  ctx.stroke();
  ctx.restore();

  // æ˜¾ç¤ºä¿¡æ¯
  hoverInfo.innerHTML = `f = ${freq.toFixed(1)} Hz<br>${amp} dB`;
  hoverInfo.style.left = e.pageX + 10 + "px";
  hoverInfo.style.top = e.pageY - 20 + "px";
  hoverInfo.style.display = "block";
});

canvas.addEventListener("mouseleave", () => {
  hoverInfo.style.display = "none";
});
   // å¯¼å‡º ESS è°æ³¢å“åº”æ•°æ®åˆ° CSV
document.getElementById("exportCSV").addEventListener("click", () => {
  if (!window._essData) {
    alert("è¯·å…ˆè¿è¡Œ ESS æ‰«æï¼");
    return;
  }

  const { sr, fftSizeIR, harmonics, harmonicFRFs } = window._essData;
  let csv = "Freq(Hz)";
  harmonics.forEach(h => csv += `,H${h}(dB)`);
  csv += "\n";

  const points = fftSizeIR / 2;
  for (let i = 0; i < points; i++) {
    const f = i * sr / fftSizeIR;
    csv += f.toFixed(2);
    harmonics.forEach(h => {
      csv += `,${harmonicFRFs[h][i].toFixed(3)}`;
    });
    csv += "\n";
  }

  const blob = new Blob([csv], { type: "text/csv" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "ESS_Harmonics.csv";
  a.click();
  URL.revokeObjectURL(url);

  alert("CSV å¯¼å‡ºå®Œæˆï¼");
});
    // ========== 5.5 è®¡ç®—å„è°æ³¢å³°å€¼ ==========
const peakInfo = [];
for (const h of harmonics) {
  const frf = harmonicFRFs[h];
  let peakVal = -Infinity, peakIdx = 0;
  for (let i = 0; i < frf.length; i++) {
    if (frf[i] > peakVal) {
      peakVal = frf[i];
      peakIdx = i;
    }
  }
  const peakFreq = (peakIdx * sr / fftSizeIR).toFixed(2);
  peakInfo.push({ harmonic: h, freq: peakFreq, amp: peakVal.toFixed(2) });

  // ç»˜å›¾æ ‡æ³¨æ–‡å­—
  ctx.fillStyle = "#fff";
  ctx.font = "12px monospace";
  const x = (peakIdx / frf.length) * canvas.width;
  const y = canvas.height - ((frf[peakIdx] - minVal) / (maxVal - minVal + 1e-12)) * canvas.height;
  ctx.fillText(`H${h}: ${peakFreq}Hz / ${peakVal.toFixed(1)}dB`, x + 5, y - 5);
}
console.table(peakInfo);
    // ========== 5.7 è‡ªåŠ¨ç”Ÿæˆåˆ†ææŠ¥å‘Š ==========
let report = "ğŸ“ˆ ESS è°æ³¢å“åº”åˆ†ææŠ¥å‘Š\n\n";
report += `ä¸»å“åº”å³°å€¼é¢‘ç‡: ${peakInfo[0].freq} Hz (${peakInfo[0].amp} dB)\n`;

for (let i = 1; i < peakInfo.length; i++) {
  const h = peakInfo[i];
  const rel = (h.amp - peakInfo[0].amp).toFixed(2);
  report += `ç¬¬ ${h.harmonic} æ¬¡è°æ³¢: ${h.freq} Hz (${h.amp} dB)   ç›¸å¯¹ä¸»å“åº”: ${rel} dB\n`;
}

// ä¼°ç®—ä¿¡å™ªæ¯”
const snr = (peakInfo[0].amp - Math.min(...peakInfo.map(h => h.amp))).toFixed(2);
report += `\nä¼°è®¡ä¿¡å™ªæ¯”(SNR): ${snr} dB\n`;

document.getElementById("essReportText").textContent = report;
console.log(report);
  // ========== 6. ä¿å­˜å¯¼å‡ºæ•°æ® ==========
  window._essData = {
    sr,
    fftSizeIR,
    f1,
    f2,
    harmonics,
    harmonicFRFs
  };
   console.log("ESS å®Œæˆï¼Œè°æ³¢å“åº”å·²ä¿å­˜ã€‚");
   micStream.getTracks().forEach(track => track.stop());
  };
};
  // å¯¼å‡º ESS è°æ³¢å“åº”æ•°æ®åˆ° CSV
document.getElementById("exportCSV").addEventListener("click", () => {
  if (!window._essData) {
    alert("è¯·å…ˆè¿è¡Œ ESS æ‰«æï¼");
    return;
  }

  const { sr, fftSizeIR, harmonics, harmonicFRFs } = window._essData;
  let csv = "Freq(Hz)";
  harmonics.forEach(h => csv += `,H${h}(dB)`);
  csv += "\n";

  const points = fftSizeIR / 2;
  for (let i = 0; i < points; i++) {
    const f = i * sr / fftSizeIR;
    csv += f.toFixed(2);
    harmonics.forEach(h => {
      csv += `,${harmonicFRFs[h][i].toFixed(3)}`;
    });
    csv += "\n";
  }

  const blob = new Blob([csv], { type: "text/csv" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "ESS_Harmonics.csv";
  a.click();
  URL.revokeObjectURL(url);

  alert("CSV å¯¼å‡ºå®Œæˆï¼");
});
  // =============== æŒ‰é’®ç»‘å®š ===============
  document.getElementById("essBtn").onclick = playAndRecordESS;
  //===============æ•²å‡»æ£€æµ‹====================
(async function(){
  const $ = id => document.getElementById(id);
  const tapBtn = $('tapDetectBtn');
  const dlBtn = $('downloadTap');
  const tapFreqEl = $('tapFreq');
  const waveCan = $('tapWave');
  const wctx = waveCan.getContext('2d');

  // è‡ªç›¸å…³åŸºé¢‘ä¼°è®¡ï¼ˆé€‚åˆæ•²å‡»/çŸ­ç¬æ€çš„é•¿è®°å½•ï¼‰
  function estimatePitchAutocorrLong(buf, sampleRate, minF=20, maxF=8000){
    const N = buf.length;
    // å»ç›´æµå¹¶çª—
    let mean = 0;
    for (let i=0;i<N;i++) mean += buf[i];
    mean /= N;
    const xs = new Float32Array(N);
    for (let i=0;i<N;i++){
      xs[i] = buf[i] - mean;
    }
    // å¯é€‰æ±‰å®çª—
    for (let i=0;i<N;i++){
      const hann = 0.5*(1 - Math.cos(2*Math.PI*i/(N-1)));
      xs[i] *= hann;
    }

    const minLag = Math.floor(sampleRate / Math.min(maxF, Math.max(minF, 1)));
    const maxLag = Math.floor(sampleRate / Math.max(minF, 1));
    let bestLag=-1, bestCorr=0;
    // ä½¿ç”¨ä¸‹é‡‡æ ·åŠ é€Ÿè‡ªç›¸å…³æœç´¢ï¼šå…ˆå¯¹ xs åš 2 å€ä¸‹é‡‡æ ·ï¼ˆå¯è°ƒæ•´ï¼‰
    const step = 1; // å¦‚æœéœ€è¦æ›´å¿«å¯æ”¹ä¸º 2 æˆ– 4ï¼Œä½†ä¼šé™ä½ç²¾åº¦
    for (let lag = minLag; lag <= maxLag; lag += step) {
      let corr = 0;
      for (let i=0;i+lag<N;i++){
        corr += xs[i]*xs[i+lag];
      }
      if (corr > bestCorr){
        bestCorr = corr;
        bestLag = lag;
      }
    }
    if (bestLag <= 0 || bestCorr <= 1e-8) return -1;
    // ä¸‰ç‚¹æŠ›ç‰©çº¿æ’å€¼æå‡ç²¾åº¦
    const c = (lag) => {
      let s=0;
      for (let i=0;i+lag<N;i++) s += xs[i]*xs[i+lag];
      return s;
    };
    const c1 = c(bestLag-1), c2 = c(bestLag), c3 = c(bestLag+1);
    const denom = (c1 - 2*c2 + c3);
    let shift = 0;
    if (Math.abs(denom) > 1e-12) shift = 0.5*(c1 - c3)/denom;
    const refinedLag = bestLag + shift;
    const freq = sampleRate / refinedLag;
    if (!isFinite(freq) || freq <= 0) return -1;
    return freq;
  }

  // å°†å½•åˆ°çš„ AudioBuffer å¯¼å‡ºæˆ WAV Blob
  function audioBufferToWavBlob(buffer){
    const numOfChan = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const len = buffer.length * numOfChan * 2 + 44;
    const buf = new ArrayBuffer(len);
    const view = new DataView(buf);
    // RIFF header
    function writeString(view, offset, string){
      for (let i=0;i<string.length;i++) view.setUint8(offset+i, string.charCodeAt(i));
    }
    writeString(view, 0, 'RIFF'); view.setUint32(4, 36 + buffer.length * numOfChan * 2, true);
    writeString(view, 8, 'WAVE');
    writeString(view, 12, 'fmt '); view.setUint32(16, 16, true);
    view.setUint16(20, 1, true); // PCM
    view.setUint16(22, numOfChan, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * numOfChan * 2, true);
    view.setUint16(32, numOfChan * 2, true);
    view.setUint16(34, 16, true);
    writeString(view, 36, 'data'); view.setUint32(40, buffer.length * numOfChan * 2, true);
    // write interleaved
    let offset = 44;
    const interleaved = new Int16Array(buffer.length * numOfChan);
    for (let i=0;i<buffer.length;i++){
      for (let ch=0; ch<numOfChan; ch++){
        const sample = Math.max(-1, Math.min(1, buffer.getChannelData(ch)[i]));
        interleaved[i*numOfChan + ch] = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
      }
    }
    for (let i=0;i<interleaved.length;i++){
      view.setInt16(offset, interleaved[i], true);
      offset += 2;
    }
    return new Blob([view], { type:'audio/wav' });
  }

  // ç”»æ—¶åŸŸæ³¢å½¢
  function drawWave(buf, sr){
    const N = buf.length;
    wctx.clearRect(0,0,waveCan.width,waveCan.height);
    wctx.fillStyle = '#061225';
    wctx.fillRect(0,0,waveCan.width,waveCan.height);
    wctx.lineWidth = 2; wctx.strokeStyle = '#5fc0ff';
    wctx.beginPath();
    const step = Math.ceil(N / waveCan.width);
    const mid = waveCan.height/2;
    for (let x=0, i=0; x<waveCan.width && i<N; x++, i += step){
      const v = buf[i];
      const y = mid + v * mid * 0.85;
      if (x===0) wctx.moveTo(x,y); else wctx.lineTo(x,y);
    }
    wctx.stroke();
  }

  tapBtn.addEventListener('click', async ()=>{
    tapBtn.disabled = true;
    tapBtn.textContent = 'å½•éŸ³ä¸­â€¦ è¯·æ•²å‡» 2 ç§’';
    tapFreqEl.textContent = 'â€¦';
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: { channelCount:1, sampleRate: 44100 }});
      const mediaRec = new MediaRecorder(stream);
      const chunks = [];
      mediaRec.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
      mediaRec.start();
      await new Promise(r => setTimeout(r, 2000));
      mediaRec.stop();
      await new Promise(resolve => mediaRec.onstop = resolve);

      const blob = new Blob(chunks, { type: 'audio/webm' });
      const arrayBuffer = await blob.arrayBuffer();

      // decode to AudioBuffer for high quality float samples
      const decoded = await audioCtx.decodeAudioData(arrayBuffer);
      // prefer first channel
      const chData = decoded.getChannelData(0);
      // ç»˜åˆ¶æ—¶åŸŸ
      drawWave(chData, decoded.sampleRate);

      // è¿è¡Œè‡ªç›¸å…³åŸºé¢‘ä¼°è®¡ï¼ˆé•¿è®°å½•æ›´å‡†ç¡®ï¼‰
      const freq = estimatePitchAutocorrLong(chData, decoded.sampleRate, 20, 8000);
      if (freq > 0) {
        tapFreqEl.textContent = freq.toFixed(2);
      } else {
        tapFreqEl.textContent = 'æœªæ£€æµ‹åˆ°æ˜æ˜¾åŸºé¢‘';
      }

      // æä¾›ä¸‹è½½
      const wavBlob = audioBufferToWavBlob(decoded);
      const url = URL.createObjectURL(wavBlob);
      dlBtn.href = url;
      dlBtn.download = 'tap_record.wav';
      dlBtn.style.display = 'inline-block';
      dlBtn.onclick = ()=> { setTimeout(()=>URL.revokeObjectURL(url), 5000); };

      // stop tracks
      stream.getTracks().forEach(t=>t.stop());
      audioCtx.close();

    } catch (e) {
      console.error(e);
      alert('å½•éŸ³å¤±è´¥ï¼š' + e.message);
      tapFreqEl.textContent = 'é”™è¯¯';
    } finally {
      tapBtn.disabled = false;
      tapBtn.textContent = 'æ•²å‡»æ£€æµ‹ï¼ˆå½•éŸ³ 2sï¼‰';
    }
  });
})();
  document.getElementById("exportCSV").onclick = () => {
  const d = window._essData;
  if (!d || !d.frf || d.frf.length === 0) {
    alert("è¿˜æ²¡æœ‰å¯å¯¼å‡ºçš„æ•°æ®ï¼Œè¯·å…ˆè¿è¡Œ ESSã€‚");
    return;
  }
  let csv = "Frequency(Hz),Magnitude(dB)\n";
  for (let i = 0; i < d.frf.length; i++) {
    const f = i * d.sampleRate / d.fftSizeIR;
    csv += `${f},${d.frf[i]}\n`;
  }
  const blob = new Blob([csv], { type: "text/csv" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "ess_response.csv";
  a.click();
  URL.revokeObjectURL(url);
};
</script>
</body>
</html>
