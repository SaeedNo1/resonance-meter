<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>resonance-meter</title>
<link rel="icon" type="image/png" sizes="48x48" href="logo-42px.png">
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:#0f1724;color:#e6eef8;margin:0;padding:16px}
  .wrap{max-width:900px;margin:0 auto}
  h1{font-size:20px;margin:6px 0 12px}
  .card{background:#0b1220;border:1px solid #1f2a44;border-radius:12px;padding:12px;margin-bottom:12px}
  label{font-size:13px;color:#9fb0d6;display:block;margin-top:8px}
  input,select,button{font-size:15px;padding:8px;border-radius:8px;border:1px solid #26364f;background:#081024;color:#e6eef8;width:100%;box-sizing:border-box}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .controls{display:flex;gap:8px;margin-top:8px;flex-wrap:wrap}
  button{cursor:pointer;transition:background 0.2s}
  button:hover{filter:brightness(1.1)}
  button:disabled{opacity:0.5;cursor:not-allowed}
  button.primary{background:#3fa7ff;border:none;color:#032033}
  canvas{width:100%;height:240px;background:#061225;border-radius:8px;border:1px solid #22314a;display:block}
  .pill{display:inline-block;padding:8px 12px;border-radius:999px;background:#07162b;color:#bfe0ff;margin-right:8px;font-size:13px}
  .small{font-size:13px;color:#95b7dc}
  .hint{font-size:12px;color:#95b7dc;margin-top:8px;line-height:1.4}
  a{color:#82c1ff}
  #hud{font-family:monospace; color:#0f0; margin-top:10px;}
  #essReport{margin-top:10px; padding:10px; background:#111; color:#0f0; font-family:monospace; border-radius:6px; overflow-x:auto;}
  .checkbox-group { display:flex; gap:10px; margin-top:8px; align-items:center; }
  .checkbox-group label { margin:0; cursor:pointer; display:flex; align-items:center; gap:4px; color:#fff;}
</style>
</head>
<body>
<div class="wrap">
  <h1>固有频率扫测</h1>

  <div class="card">
    <div class="row">
      <div>
        <label>起始频率 (Hz)</label>
        <input id="fStart" type="number" value="50" step="1" min="1" />
      </div>
      <div>
        <label>终止频率 (Hz)</label>
        <input id="fEnd" type="number" value="2000" step="1" min="1" />
      </div>
    </div>

    <div class="row">
      <div>
        <label>步数 (Step Sweep)</label>
        <input id="steps" type="number" value="80" min="2" />
      </div>
      <div>
        <label>每步时长 (ms)</label>
        <input id="dur" type="number" value="120" min="20" />
      </div>
      <div>
        <label>ESS时长 (s)</label>
        <input id="essDur" type="number" value="10" step="1" min="1" />
      </div>
    </div>
    <label>波形 (仅步进扫频有效)</label>
    <select id="wave">
      <option value="sine">正弦</option>
      <option value="triangle">三角</option>
      <option value="sawtooth">锯齿</option>
      <option value="square">方波</option>
    </select>
    
    <label>ESS 谐波展示</label>
    <div class="checkbox-group" id="harmonicSelector">
      <label><input type="checkbox" class="hToggle" value="1" checked> H1 (基频)</label>
      <label><input type="checkbox" class="hToggle" value="2" checked> H2</label>
      <label><input type="checkbox" class="hToggle" value="3" checked> H3</label>
      <label><input type="checkbox" class="hToggle" value="4" checked> H4</label>
    </div>
    
    <label>音量 (播放增益 0-1)</label>
    <input id="gain" type="range" min="0" max="1" step="0.01" value="0.8" />

    <div class="controls">
      <button id="startSweep" class="primary">步进扫频</button>
      <button id="essBtn" class="primary" style="background:#b066ff;color:#fff">ESS 扫频测试</button>
      <button id="stopSweep">停止</button>
      <button id="baselineBtn">采集背景</button>
      <button id="exportCSV">导出 CSV</button>
      <button onclick="location.href='Frequency.html'">准备共振</button>
    </div>

    <div id="hud">
      当前频率: <span id="hudFreq">—</span> Hz　
      进度: <span id="hudProg">0</span>%
    </div>

    <div style="margin-top:10px">
      <span class="pill">检测峰值：<span id="peakFreq">—</span> Hz</span>
      <span class="pill">峰值幅度：<span id="peakAmp">—</span></span>
    </div>
    <div class="hint">
      ESS (指数正弦扫) 是一种高精度的音频测量方法。它能同时分离系统的线性响应和非线性谐波失真。
      <br>注意：请将麦克风靠近被测物体，并保持环境安静。
    </div>
    <a href="introduce/ESS.html">关于指数正弦扫(ESS)</a>
  </div>

  <div class="card">
    <canvas id="plot" width="800" height="320"></canvas>
  </div>
  
  <div id="essReport">
    <b>分析报告：</b>
    <pre id="essReportText">（等待 ESS 扫描结果...）</pre>
  </div>

  <div style="padding:8px; margin-top:8px;">
    <h3>脉冲/敲击检测</h3>
    <div class="controls">
      <button id="tapDetectBtn">敲击检测 (录音 2s)</button>
      <label style="display:inline-flex;align-items:center;width:auto;margin:0;">
        <input type="checkbox" id="enableHPF" style="width:auto;margin-right:4px;"> 高通滤波
      </label>
      <input type="number" id="hpfValue" value="50" min="0" max="500" style="width:70px;margin-left:4px;"> Hz
      <a id="downloadTap" style="display:none;align-self:center;" href="#">下载录音 (WAV)</a>
    </div>
    <div style="margin-top:8px;">
      <span class="pill">敲击基频: <span id="tapFreq">—</span> Hz</span>
    </div>
    <canvas id="tapWave" width="600" height="120" style="margin-top:8px;border-radius:6px;background:#061225;width:100%"></canvas>
  </div>
</div>

<script src="JS/fft.js"></script>
<script>
// ==================== 全局工具与状态 ====================
const $ = id => document.getElementById(id);
let audioCtx = null;
let currentOsc = null;      // 用于步进扫频
let currentEssSrc = null;   // 用于 ESS 播放源
let isRunning = false;
let globalEssData = null;   // 存储最新的 ESS 分析结果
let globalStepData = null;  // 存储最新的步进扫频结果
let micStream = null;

// 获取或初始化 AudioContext
function getAudioCtx() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive' });
  }
  return audioCtx;
}

// 停止所有音频活动
async function stopAll() {
  isRunning = false;
  if (currentOsc) {
    try { currentOsc.stop(); currentOsc.disconnect(); } catch(e){}
    currentOsc = null;
  }
  if (currentEssSrc) {
    try { currentEssSrc.stop(); currentEssSrc.disconnect(); } catch(e){}
    currentEssSrc = null;
  }
  if (micStream) {
    micStream.getTracks().forEach(t => t.stop());
    micStream = null;
  }
  if (audioCtx && audioCtx.state !== 'closed') {
    try { await audioCtx.suspend(); } catch(e){}
  }
  $('hudFreq').textContent = '—';
  $('hudProg').textContent = '0';
}

// 辅助：休眠
const sleep = ms => new Promise(r => setTimeout(r, ms));

// 辅助：RMS 计算
function getRMS(buf) {
  let sum = 0;
  for (let i = 0; i < buf.length; i++) sum += buf[i] * buf[i];
  return Math.sqrt(sum / buf.length);
}

// 辅助：创建高通滤波器
function createHPF(ctx, freq) {
  const hpf = ctx.createBiquadFilter();
  hpf.type = 'highpass';
  hpf.frequency.value = freq;
  return hpf;
}

// ==================== 1. 步进扫频 (Discrete Sweep) ====================
async function runStepSweep() {
  if (isRunning) return;
  const ctx = getAudioCtx();
  await ctx.resume();
  isRunning = true;
  globalStepData = []; // 清空数据
  
  // 参数获取
  const fStart = parseFloat($('fStart').value) || 50;
  const fEnd = parseFloat($('fEnd').value) || 2000;
  let steps = parseInt($('steps').value) || 80;
  const dur = parseFloat($('dur').value) || 120;
  const waveType = $('wave').value;
  const gainVal = parseFloat($('gain').value);

  // 麦克风设置
  let analyser;
  try {
    micStream = await navigator.mediaDevices.getUserMedia({ audio: { 
      echoCancellation: false, noiseSuppression: false, autoGainControl: false 
    }});
    const micSrc = ctx.createMediaStreamSource(micStream);
    analyser = ctx.createAnalyser();
    analyser.fftSize = 2048;
    micSrc.connect(analyser);
  } catch (e) {
    alert("麦克风启动失败: " + e.message);
    isRunning = false;
    return;
  }

  // 输出设置
  const gainNode = ctx.createGain();
  gainNode.gain.value = gainVal;
  gainNode.connect(ctx.destination);

  // 绘图准备
  const plotCanvas = $('plot');
  const g = plotCanvas.getContext('2d');
  
  // 频率序列 (对数分布)
  const freqs = [];
  for (let i = 0; i < steps; i++) {
    const t = i / (steps - 1);
    freqs.push(fStart * Math.pow(fEnd / fStart, t));
  }

  // 扫描循环
  const timeData = new Float32Array(analyser.fftSize);
  for (let i = 0; i < freqs.length; i++) {
    if (!isRunning) break;
    const f = freqs[i];

    // 更新 HUD
    $('hudFreq').textContent = f.toFixed(1);
    $('hudProg').textContent = Math.round((i / steps) * 100);

    // 播放单音
    currentOsc = ctx.createOscillator();
    currentOsc.type = waveType;
    currentOsc.frequency.setValueAtTime(f, ctx.currentTime);
    currentOsc.connect(gainNode);
    currentOsc.start();

    // 等待稳定
    const stableMs = Math.max(10, dur * 0.5);
    await sleep(stableMs);

    // 采样
    let rmsSum = 0;
    let count = 0;
    const measureEnd = performance.now() + (dur - stableMs);
    while (performance.now() < measureEnd) {
      analyser.getFloatTimeDomainData(timeData);
      rmsSum += getRMS(timeData);
      count++;
      await sleep(5);
    }
    
    // 记录
    const amp = count > 0 ? rmsSum / count : 0;
    globalStepData.push({ f, amp });
    
    // 停止单音
    currentOsc.stop();
    currentOsc.disconnect();
    currentOsc = null;

    // 实时绘图
    drawStepPlot(g, globalStepData, fStart, fEnd);
    
    // 短暂间隔
    await sleep(10);
  }

  // 结束处理
  isRunning = false;
  micStream.getTracks().forEach(t => t.stop());
  micStream = null;
  
  // 找峰值
  if (globalStepData.length > 0) {
    const peak = globalStepData.reduce((a, b) => b.amp > a.amp ? b : a);
    $('peakFreq').textContent = peak.f.toFixed(1);
    $('peakAmp').textContent = peak.amp.toFixed(4);
  }
}

function drawStepPlot(ctx, data, fMin, fMax) {
  const w = ctx.canvas.width;
  const h = ctx.canvas.height;
  ctx.fillStyle = "#061225";
  ctx.fillRect(0, 0, w, h);
  
  if (data.length === 0) return;

  // 绘制网格
  drawGrid(ctx, fMin, fMax);

  // 绘制数据
  const maxAmp = Math.max(...data.map(p => p.amp), 0.0001);
  ctx.beginPath();
  ctx.strokeStyle = "#3fa7ff";
  ctx.lineWidth = 2;
  
  const logMin = Math.log10(fMin);
  const logMax = Math.log10(fMax);
  const scaleX = w / (logMax - logMin);

  for (let i = 0; i < data.length; i++) {
    const p = data[i];
    const x = (Math.log10(p.f) - logMin) * scaleX;
    const y = h - (p.amp / maxAmp) * (h - 20) - 10;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();
}


// ==================== 2. ESS (指数正弦扫) 核心逻辑 ====================

// 生成 ESS 信号与逆滤波器
function generateESSVectors(f1, f2, duration, sampleRate) {
  const N = Math.floor(duration * sampleRate);
  const w1 = 2 * Math.PI * f1;
  const w2 = 2 * Math.PI * f2;
  const L = (duration * w1) / Math.log(w2 / w1); // 变换系数
  const K = Math.log(w2 / w1) / duration;        // 指数率
  
  const sweep = new Float32Array(N);
  const inverse = new Float32Array(N);
  
  // 生成 Log Sweep
  // x(t) = sin[ L * (exp(t*K) - 1) ]
  for (let n = 0; n < N; n++) {
    const t = n / sampleRate;
    const phase = L * (Math.exp(t * K) - 1);
    sweep[n] = Math.sin(phase);
  }

  // 生成 Inverse Filter
  // 逆滤波器是时间反转的扫频信号，并按频率进行幅度调制(由 -6dB/oct 变为 0dB/oct 对应白化)
  // 幅度包络 m(t) = w1 / w(t) = exp(-t*K)
  for (let n = 0; n < N; n++) {
    const t = n / sampleRate;
    const invT = (N - 1 - n) / sampleRate; // 时间反转索引对应的时间
    
    // 生成反转信号的相位 (同 sweep 但时间倒置)
    // 实际上直接用 sweep[N-1-n] 乘以包络即可
    const modulation = Math.exp(-t * K); 
    // inverse[n] = sweep[N - 1 - n] * modulation; 
    // 注意: 为了完全反卷积，包络需要应用于反转后的时间轴
    inverse[n] = sweep[N - 1 - n] * Math.exp(- (N - 1 - n) / sampleRate * K);
  }

  // 归一化 inverse 以避免增益过大
  const maxVal = inverse.reduce((m, v) => Math.max(m, Math.abs(v)), 0);
  for (let i=0; i<N; i++) inverse[i] /= maxVal;

  return { sweep, inverse };
}

// 快速卷积/反卷积 (Frequency Domain)
// 要求 fft.js 已加载
function convolve(signal, filter) {
  if (typeof FFT === 'undefined') throw new Error("FFT库未加载");
  
  const nSig = signal.length;
  const nFilt = filter.length;
  // 卷积结果长度为 M+N-1，FFT需要为2的幂次
  let len = nSig + nFilt - 1;
  let fftSize = 1;
  while (fftSize < len) fftSize *= 2;

  const fft = new FFT(fftSize);
  const sigPad = new Float32Array(fftSize);
  const filtPad = new Float32Array(fftSize);
  
  sigPad.set(signal);
  filtPad.set(filter);

  const sigComplex = fft.createComplexArray();
  const filtComplex = fft.createComplexArray();
  const resComplex = fft.createComplexArray();

  fft.realTransform(sigComplex, sigPad);
  fft.realTransform(filtComplex, filtPad);

  // 复数乘法: Res = Sig * Filt
  for (let i = 0; i < fftSize; i++) {
    const reS = sigComplex[2*i];
    const imS = sigComplex[2*i+1];
    const reF = filtComplex[2*i];
    const imF = filtComplex[2*i+1];
    
    resComplex[2*i]   = reS * reF - imS * imF;
    resComplex[2*i+1] = reS * imF + imS * reF;
  }

  const result = new Float32Array(fftSize);
  fft.inverseTransform(result, resComplex);
  
  // 仅返回有效部分，且做归一化
  return result; // 此时未缩放，IFFT通常不需要额外除N(取决于库实现)，fft.js需要看文档，通常它不除。
  // 我们后续处理归一化，所以这里只要相对形状对即可。
}

async function runESS() {
  if (isRunning) return;
  const ctx = getAudioCtx();
  await ctx.resume();
  isRunning = true;
  globalEssData = null;
  $('essReportText').textContent = "正在生成 ESS 信号...";
  $('peakFreq').textContent = "—";
  
  // 1. 获取参数
  const fStart = parseFloat($('fStart').value) || 50;
  const fEnd = parseFloat($('fEnd').value) || 2000;
  const dur = parseFloat($('essDur').value) || 10;
  const gainVal = parseFloat($('gain').value);
  const sampleRate = ctx.sampleRate;

  // 2. 生成信号
  const { sweep, inverse } = generateESSVectors(fStart, fEnd, dur, sampleRate);

  // 3. 准备播放与录音
  const sweepBuf = ctx.createBuffer(1, sweep.length, sampleRate);
  sweepBuf.copyToChannel(sweep, 0);

  let recorder;
  let inputChunks = [];
  
  try {
    micStream = await navigator.mediaDevices.getUserMedia({ audio: { 
      echoCancellation: false, noiseSuppression: false, autoGainControl: false 
    }});
  } catch(e) {
    alert("麦克风错误: " + e.message);
    isRunning = false;
    return;
  }

  // 使用 MediaRecorder 录制
  // 注意：MediaRecorder 有一定启动延迟，我们先启动录制，稍等再播放
  const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') ? 'audio/webm;codecs=opus' : 'audio/webm';
  recorder = new MediaRecorder(micStream, { mimeType });
  recorder.ondataavailable = e => inputChunks.push(e.data);

  recorder.start();
  $('essReportText').textContent = "正在录制响应...";
  
  // 延迟 200ms 确保录音机启动
  await sleep(200);

  // 播放
  const src = ctx.createBufferSource();
  src.buffer = sweepBuf;
  const gainNode = ctx.createGain();
  gainNode.gain.value = gainVal;
  src.connect(gainNode);
  gainNode.connect(ctx.destination);
  
  currentEssSrc = src;
  src.start();
  
  const startTime = ctx.currentTime;
  
  // HUD 动画
  const hudInterval = setInterval(() => {
    if (!isRunning) { clearInterval(hudInterval); return; }
    const elapsed = ctx.currentTime - startTime;
    let prog = (elapsed / dur) * 100;
    if (prog > 100) prog = 100;
    $('hudProg').textContent = prog.toFixed(0);
    
    if (elapsed <= dur) {
      // 瞬时频率计算 f(t) = f1 * (f2/f1)^(t/T)
      const instF = fStart * Math.pow(fEnd/fStart, elapsed/dur);
      $('hudFreq').textContent = instF.toFixed(1);
    }
  }, 100);

  // 等待播放结束 + 混响拖尾 (1s)
  await sleep(dur * 1000 + 1000);
  
  clearInterval(hudInterval);
  src.stop();
  recorder.stop();
  currentEssSrc = null;

  $('essReportText').textContent = "正在处理卷积与分析...";

  // 等待录音数据完成
  await new Promise(resolve => recorder.onstop = resolve);
  micStream.getTracks().forEach(t => t.stop());
  micStream = null;

  if (!isRunning) return; // 如果中途被停止

  // 4. 处理录音数据
  const blob = new Blob(inputChunks, { type: mimeType });
  const arrayBuffer = await blob.arrayBuffer();
  const audioBuf = await ctx.decodeAudioData(arrayBuffer);
  const recordedSignal = audioBuf.getChannelData(0);

  // 5. 卷积 (得到脉冲响应 IR)
  // 为了得到正确的 IR，我们将录制信号与逆滤波器卷积
  // 注意：MediaRecorder 和 播放 之间的延迟是未知的，
  // 所以得到的 IR 会有一个未知的整体时移。我们需要找到主峰。
  let ir;
  try {
    ir = convolve(recordedSignal, inverse);
  } catch (e) {
    alert("卷积计算失败: " + e.message);
    isRunning = false;
    return;
  }

  // 6. 谐波分离与分析
  analyzeHarmonics(ir, sampleRate, fStart, fEnd, dur);
  
  isRunning = false;
}

// 分析谐波并绘图
function analyzeHarmonics(ir, sr, f1, f2, dur) {
  // 找到 IR 中的最大绝对值位置 (作为 H1 的参考点)
  // 在 ESS 中，线性响应(H1)通常在 IR 的尾部（如果是循环卷积）或者根据延迟出现在某处
  // 由于我们录音比播放长，且是线性卷积，H1 应该是最强的峰
  let maxVal = -1;
  let maxIdx = 0;
  for(let i=0; i<ir.length; i++) {
    if (Math.abs(ir[i]) > maxVal) {
      maxVal = Math.abs(ir[i]);
      maxIdx = i;
    }
  }

  // 计算各谐波相对于 H1 的理论时间提前量
  // Delta_t = T * ln(h) / ln(f2/f1)
  // IR 序列中，H1 在 maxIdx 处。H2 应当出现在 maxIdx - Delta_t2 处，以此类推。
  
  const harmonics = [1, 2, 3, 4];
  const results = {}; // 存储频谱数据 { 1: {freqs, amps}, ... }
  const fftSize = 4096; // 分析窗口大小
  const fft = new FFT(fftSize);

  const freqLogBase = Math.log(f2/f1);

  harmonics.forEach(h => {
    // 计算时移 (samples)
    const dt = dur * Math.log(h) / freqLogBase;
    const shiftSamples = Math.round(dt * sr);
    
    // 提取中心位置
    const centerIdx = maxIdx - shiftSamples;
    
    // 截取窗口 (加 Hann 窗)
    const segment = new Float32Array(fftSize);
    if (centerIdx - fftSize/2 >= 0 && centerIdx + fftSize/2 < ir.length) {
      for (let i = 0; i < fftSize; i++) {
        const idx = centerIdx - fftSize/2 + i;
        // Hann window
        const win = 0.5 * (1 - Math.cos(2 * Math.PI * i / (fftSize - 1)));
        segment[i] = ir[idx] * win;
      }
    }

    // FFT
    const outComplex = fft.createComplexArray();
    fft.realTransform(outComplex, segment);
    
    // 计算幅度谱 (dB)
    const amps = [];
    const freqs = [];
    for (let i = 0; i < fftSize/2; i++) {
      const re = outComplex[2*i];
      const im = outComplex[2*i+1];
      const mag = Math.sqrt(re*re + im*im);
      const db = 20 * Math.log10(mag + 1e-9);
      amps.push(db);
      freqs.push(i * sr / fftSize);
    }
    results[h] = { freqs, amps };
  });

  // 保存全局数据以便导出
  globalEssData = { results, f1, f2, harmonics };

  // 绘图
  drawESSPlot(results, f1, f2);
  
  // 生成报告
  generateReport(results, f1, f2);
}

function drawESSPlot(results, fMin, fMax) {
  const canvas = $('plot');
  const ctx = canvas.getContext('2d');
  const w = canvas.width;
  const h = canvas.height;
  
  ctx.clearRect(0, 0, w, h);
  ctx.fillStyle = "#061225";
  ctx.fillRect(0, 0, w, h);

  drawGrid(ctx, fMin, fMax);

  // 获取显示的谐波
  const visibleHarmonics = Array.from(document.querySelectorAll('.hToggle'))
    .filter(c => c.checked).map(c => parseInt(c.value));
  
  // 自动缩放 Y 轴
  let maxDb = -100;
  visibleHarmonics.forEach(k => {
    if(results[k]) maxDb = Math.max(maxDb, ...results[k].amps);
  });
  const topDb = Math.ceil(maxDb / 10) * 10 + 10;
  const bottomDb = topDb - 80; // 显示 80dB 范围

  const colors = {1: '#3fa7ff', 2: '#ffcf6b', 3: '#ff6b6b', 4: '#6bff8e'};

  const logMin = Math.log10(fMin);
  const logMax = Math.log10(fMax);
  const scaleX = w / (logMax - logMin);

  visibleHarmonics.forEach(k => {
    if (!results[k]) return;
    const { freqs, amps } = results[k];
    
    ctx.beginPath();
    ctx.strokeStyle = colors[k] || '#fff';
    ctx.lineWidth = k === 1 ? 2 : 1;
    
    let started = false;
    for (let i = 0; i < freqs.length; i++) {
      const f = freqs[i];
      if (f < fMin || f > fMax) continue;
      
      const x = (Math.log10(f) - logMin) * scaleX;
      const y = h - ((amps[i] - bottomDb) / (topDb - bottomDb)) * h;
      
      if (!started) { ctx.moveTo(x, y); started = true; }
      else ctx.lineTo(x, y);
    }
    ctx.stroke();
  });

  // 图例
  let lx = 60;
  visibleHarmonics.forEach(k => {
    ctx.fillStyle = colors[k];
    ctx.font = "12px sans-serif";
    ctx.fillText(`H${k}`, lx, 20);
    lx += 40;
  });
}

function drawGrid(ctx, fMin, fMax) {
  const w = ctx.canvas.width;
  const h = ctx.canvas.height;
  const logMin = Math.log10(fMin);
  const logMax = Math.log10(fMax);
  const scaleX = w / (logMax - logMin);

  ctx.strokeStyle = "#1f2a44";
  ctx.lineWidth = 1;
  ctx.fillStyle = "#5c6b8f";
  ctx.font = "10px sans-serif";

  // 频率网格 (10, 100, 1000...)
  for (let exp = 1; exp < 5; exp++) {
    const base = Math.pow(10, exp);
    [1, 2, 5].forEach(mult => {
      const f = base * mult;
      if (f >= fMin && f <= fMax) {
        const x = (Math.log10(f) - logMin) * scaleX;
        ctx.beginPath();
        ctx.moveTo(x, 0); ctx.lineTo(x, h);
        ctx.stroke();
        ctx.fillText(f >= 1000 ? (f/1000)+'k' : f, x+2, h-6);
      }
    });
  }
}

function generateReport(results, f1, f2) {
  if (!results[1]) return;
  const h1 = results[1];
  
  // 找峰值频率
  let peakVal = -999;
  let peakF = 0;
  for(let i=0; i<h1.amps.length; i++) {
    if(h1.freqs[i] >= f1 && h1.freqs[i] <= f2) {
      if(h1.amps[i] > peakVal) {
        peakVal = h1.amps[i];
        peakF = h1.freqs[i];
      }
    }
  }

  $('peakFreq').textContent = peakF.toFixed(1);
  $('peakAmp').textContent = peakVal.toFixed(1) + " dB";

  let txt = `=== ESS 分析报告 ===\n`;
  txt += `频率范围: ${f1}Hz - ${f2}Hz\n`;
  txt += `主响应峰值 (H1): ${peakF.toFixed(1)} Hz @ ${peakVal.toFixed(1)} dB\n`;
  
  [2, 3, 4].forEach(k => {
    if (results[k]) {
      // 计算该谐波在主峰频率处的幅度（近似）
      // 实际上谐波失真通常看 THD，这里简单列出该频率下的值
      // 为了简单，我们找出该谐波曲线的最高点
      let hPeak = -999;
      results[k].amps.forEach(a => hPeak = Math.max(hPeak, a));
      txt += `H${k} 最大失真: ${hPeak.toFixed(1)} dB (相对H1: ${(hPeak - peakVal).toFixed(1)} dB)\n`;
    }
  });
  
  $('essReportText').textContent = txt;
}

// ==================== 3. 敲击检测与辅助功能 ====================

$('tapDetectBtn').addEventListener('click', async function() {
  const btn = this;
  btn.disabled = true;
  btn.textContent = "录音中...";
  const ctx = getAudioCtx();
  await ctx.resume();

  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const rec = new MediaRecorder(stream);
    const chunks = [];
    rec.ondataavailable = e => chunks.push(e.data);
    rec.start();
    
    await sleep(2000);
    rec.stop();
    await new Promise(r => rec.onstop = r);
    stream.getTracks().forEach(t => t.stop());

    const blob = new Blob(chunks, { type: 'audio/webm' });
    const buf = await blob.arrayBuffer();
    const audioB = await ctx.decodeAudioData(buf);
    let data = audioB.getChannelData(0);

    // 高通滤波处理 (如果勾选)
    if ($('enableHPF').checked) {
      const hpfFreq = parseFloat($('hpfValue').value) || 50;
      // 离线处理滤波
      const offlineCtx = new OfflineAudioContext(1, data.length, audioB.sampleRate);
      const src = offlineCtx.createBufferSource();
      src.buffer = audioB;
      const hpf = offlineCtx.createBiquadFilter();
      hpf.type = 'highpass';
      hpf.frequency.value = hpfFreq;
      src.connect(hpf);
      hpf.connect(offlineCtx.destination);
      src.start();
      const rendered = await offlineCtx.startRendering();
      data = rendered.getChannelData(0);
    }

    drawWaveform(data, $('tapWave'));
    
    // 简单自相关基频检测
    const pitch = detectPitch(data, audioB.sampleRate);
    $('tapFreq').textContent = pitch ? pitch.toFixed(1) : "未检测到";

    // 下载链接
    const wavBlob = audioBufferToWav(data, audioB.sampleRate);
    const url = URL.createObjectURL(wavBlob);
    const dl = $('downloadTap');
    dl.href = url;
    dl.download = 'tap_impulse.wav';
    dl.style.display = 'inline-block';
    
  } catch(e) {
    alert("敲击检测失败: " + e.message);
  } finally {
    btn.disabled = false;
    btn.textContent = "敲击检测 (录音 2s)";
  }
});

function drawWaveform(data, canvas) {
  const ctx = canvas.getContext('2d');
  const w = canvas.width;
  const h = canvas.height;
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = '#061225';
  ctx.fillRect(0,0,w,h);
  ctx.strokeStyle = '#5fc0ff';
  ctx.lineWidth = 1;
  ctx.beginPath();
  
  const step = Math.ceil(data.length / w);
  const amp = h / 2;
  
  for(let i=0; i < w; i++) {
    const idx = i * step;
    if(idx >= data.length) break;
    const v = data[idx];
    const y = h/2 + v * amp;
    if(i===0) ctx.moveTo(i, y);
    else ctx.lineTo(i, y);
  }
  ctx.stroke();
}

function detectPitch(buffer, sampleRate) {
  // 自相关法简易实现
  const n = 1024;
  let bestR = 0;
  let bestK = -1;
  
  // 找 RMS 最大的区域
  let maxRms = 0, startIdx = 0;
  for(let i=0; i<buffer.length - n; i+=500) {
    let sum=0;
    for(let j=0; j<n; j++) sum += buffer[i+j]*buffer[i+j];
    if(sum > maxRms) { maxRms = sum; startIdx = i; }
  }
  const slice = buffer.slice(startIdx, startIdx + n);

  for(let k = 20; k < n/2; k++) {
    let sum = 0;
    for(let i=0; i < n - k; i++) {
      sum += slice[i] * slice[i+k];
    }
    if(sum > bestR) { bestR = sum; bestK = k; }
  }
  
  if(bestK > 0) return sampleRate / bestK;
  return null;
}

// 简单的 WAV 导出工具
function audioBufferToWav(float32Array, sampleRate) {
  const buffer = new ArrayBuffer(44 + float32Array.length * 2);
  const view = new DataView(buffer);
  const writeString = (view, offset, string) => {
    for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i));
  };
  writeString(view, 0, 'RIFF');
  view.setUint32(4, 36 + float32Array.length * 2, true);
  writeString(view, 8, 'WAVE');
  writeString(view, 12, 'fmt ');
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, 1, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, sampleRate * 2, true);
  view.setUint16(32, 2, true);
  view.setUint16(34, 16, true);
  writeString(view, 36, 'data');
  view.setUint32(40, float32Array.length * 2, true);
  for (let i = 0; i < float32Array.length; i++) {
    let s = Math.max(-1, Math.min(1, float32Array[i]));
    view.setInt16(44 + i * 2, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
  }
  return new Blob([view], { type: 'audio/wav' });
}

// ==================== UI 绑定 ====================

$('startSweep').onclick = runStepSweep;
$('essBtn').onclick = runESS;
$('stopSweep').onclick = stopAll;

$('exportCSV').onclick = () => {
  if (globalEssData) {
    // 导出 ESS 数据
    let csv = "Frequency(Hz),H1(dB),H2(dB),H3(dB),H4(dB)\n";
    const h1 = globalEssData.results[1];
    if(!h1) return;
    for(let i=0; i<h1.freqs.length; i++) {
      const f = h1.freqs[i];
      if(f > globalEssData.f2) break;
      let row = `${f.toFixed(2)},${h1.amps[i].toFixed(2)}`;
      [2,3,4].forEach(k => {
        row += `,${globalEssData.results[k] ? globalEssData.results[k].amps[i].toFixed(2) : ''}`;
      });
      csv += row + "\n";
    }
    downloadCSV(csv, "ess_data.csv");
  } else if (globalStepData) {
    // 导出步进数据
    let csv = "Frequency(Hz),Amplitude\n";
    globalStepData.forEach(p => csv += `${p.f.toFixed(2)},${p.amp.toFixed(6)}\n`);
    downloadCSV(csv, "step_sweep.csv");
  } else {
    alert("暂无数据可导出");
  }
};

function downloadCSV(content, filename) {
  const blob = new Blob([content], {type: 'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = filename;
  document.body.appendChild(a); a.click(); document.body.removeChild(a);
}

// 监听复选框重绘
document.querySelectorAll('.hToggle').forEach(el => {
  el.addEventListener('change', () => {
    if (globalEssData) drawESSPlot(globalEssData.results, globalEssData.f1, globalEssData.f2);
  });
});

// 页面隐藏时清理
window.addEventListener('pagehide', stopAll);
</script>
</body>
</html>
